CCS PCH C Compiler, Version 5.025, 5967               08-cze-16 09:08

               Filename:   Z:\home\mfilipiak\Dropbox\Projekty\Elektronika\alarm\centrala\uC\main.lst

               ROM used:   11558 bytes (35%)
                           Largest free fragment is 21210
               RAM used:   47 (1%) at main() level
                           84 (2%) worst case
               Stack used: 4 locations
               Stack size: 31

*
0000:  GOTO   2624
.................... /********************************** 
....................           CENTRALKA 
.................... **********************************/ 
....................  
.................... #include <18F25k80.h>  
.................... //////////// Standard Header file for the PIC18F25K80 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F25K80 
0004:  DATA 68,20
0006:  DATA 2D,20
0008:  DATA 73,65
000A:  DATA 74,20
000C:  DATA 68,6F
000E:  DATA 75,72
0010:  DATA 0A,00
0012:  DATA 6D,20
0014:  DATA 2D,20
0016:  DATA 73,65
0018:  DATA 74,20
001A:  DATA 6D,69
001C:  DATA 6E,75
001E:  DATA 74,65
0020:  DATA 0A,00
0022:  DATA 28,75
0024:  DATA 20,2D
0026:  DATA 20,75
0028:  DATA 70,2C
002A:  DATA 20,64
002C:  DATA 20,2D
002E:  DATA 20,64
0030:  DATA 6F,77
0032:  DATA 6E,2C
0034:  DATA 20,73
0036:  DATA 20,2D
0038:  DATA 20,73
003A:  DATA 65,74
003C:  DATA 29,0A
003E:  DATA 00,00
0040:  DATA 73,61
0042:  DATA 76,65
0044:  DATA 64,0A
0046:  DATA 00,00
0048:  DATA 73,61
004A:  DATA 76,65
004C:  DATA 64,0A
004E:  DATA 00,00
0050:  DATA 53,69
0052:  DATA 72,65
0054:  DATA 6E,65
0056:  DATA 20,77
0058:  DATA 69,6C
005A:  DATA 6C,20
005C:  DATA 62,65
005E:  DATA 20,61
0060:  DATA 63,74
0062:  DATA 69,76
0064:  DATA 65,20
0066:  DATA 25,64
0068:  DATA 20,6D
006A:  DATA 69,6E
006C:  DATA 20,61
006E:  DATA 66,74
0070:  DATA 65,72
0072:  DATA 20,61
0074:  DATA 6C,61
0076:  DATA 72,6D
0078:  DATA 0A,00
007A:  DATA 53,65
007C:  DATA 74,20
007E:  DATA 74,6F
0080:  DATA 20,31
0082:  DATA 2D,31
0084:  DATA 6D,69
0086:  DATA 6E,20
0088:  DATA 32,2D
008A:  DATA 32,6D
008C:  DATA 69,6E
008E:  DATA 20,33
0090:  DATA 2D,35
0092:  DATA 6D,69
0094:  DATA 6E,0A
0096:  DATA 00,00
0098:  DATA 41,4C
009A:  DATA 41,52
009C:  DATA 4D,20
009E:  DATA 6F,6E
00A0:  DATA 20,6C
00A2:  DATA 69,6E
00A4:  DATA 65,20
00A6:  DATA 25,64
00A8:  DATA 0A,00
00AA:  DATA 25,30
00AC:  DATA 32,64
00AE:  DATA 3A,25
00B0:  DATA 30,32
00B2:  DATA 64,3A
00B4:  DATA 25,30
00B6:  DATA 32,64
00B8:  DATA 20,53
00BA:  DATA 69,72
00BC:  DATA 65,6E
00BE:  DATA 65,20
00C0:  DATA 4F,4E
00C2:  DATA 0A,00
00C4:  DATA 25,30
00C6:  DATA 32,64
00C8:  DATA 3A,25
00CA:  DATA 30,32
00CC:  DATA 64,3A
00CE:  DATA 25,30
00D0:  DATA 32,64
00D2:  DATA 20,53
00D4:  DATA 69,72
00D6:  DATA 65,6E
00D8:  DATA 65,20
00DA:  DATA 4F,46
00DC:  DATA 46,0A
00DE:  DATA 00,00
00E0:  DATA 4C,69
00E2:  DATA 6E,65
00E4:  DATA 31,20
00E6:  DATA 4F,4E
00E8:  DATA 0A,00
00EA:  DATA 4C,69
00EC:  DATA 6E,65
00EE:  DATA 31,20
00F0:  DATA 4F,46
00F2:  DATA 46,0A
00F4:  DATA 00,00
00F6:  DATA 4C,69
00F8:  DATA 6E,65
00FA:  DATA 32,20
00FC:  DATA 4F,4E
00FE:  DATA 0A,00
0100:  DATA 4C,69
0102:  DATA 6E,65
0104:  DATA 32,20
0106:  DATA 4F,46
0108:  DATA 46,0A
010A:  DATA 00,00
010C:  DATA 4C,69
010E:  DATA 6E,65
0110:  DATA 33,20
0112:  DATA 4F,4E
0114:  DATA 0A,00
0116:  DATA 4C,69
0118:  DATA 6E,65
011A:  DATA 33,20
011C:  DATA 4F,46
011E:  DATA 46,0A
0120:  DATA 00,00
0122:  DATA 4C,69
0124:  DATA 6E,65
0126:  DATA 34,20
0128:  DATA 4F,4E
012A:  DATA 0A,00
012C:  DATA 4C,69
012E:  DATA 6E,65
0130:  DATA 34,20
0132:  DATA 4F,46
0134:  DATA 46,0A
0136:  DATA 00,00
0138:  DATA 31,20
013A:  DATA 2D,20
013C:  DATA 4C,69
013E:  DATA 6E,65
0140:  DATA 20,4F
0142:  DATA 4E,2F
0144:  DATA 4F,46
0146:  DATA 46,0A
0148:  DATA 00,00
014A:  DATA 32,20
014C:  DATA 2D,20
014E:  DATA 4C,69
0150:  DATA 6E,65
0152:  DATA 20,64
0154:  DATA 65,6C
0156:  DATA 61,79
0158:  DATA 0A,00
015A:  DATA 3E,4C
015C:  DATA 69,6E
015E:  DATA 65,20
0160:  DATA 4F,4E
0162:  DATA 2F,4F
0164:  DATA 46,46
0166:  DATA 0A,00
0168:  DATA 4C,69
016A:  DATA 6E,65
016C:  DATA 20,25
016E:  DATA 64,20
0170:  DATA 69,73
0172:  DATA 20,73
0174:  DATA 65,74
0176:  DATA 20,74
0178:  DATA 6F,20
017A:  DATA 00,00
017C:  DATA 4F,4E
017E:  DATA 0A,00
0180:  DATA 4F,46
0182:  DATA 46,0A
0184:  DATA 00,00
0186:  DATA 53,65
0188:  DATA 74,20
018A:  DATA 74,6F
018C:  DATA 20,31
018E:  DATA 2D,4F
0190:  DATA 4E,20
0192:  DATA 32,2D
0194:  DATA 4F,46
0196:  DATA 46,0A
0198:  DATA 00,00
019A:  DATA 53,65
019C:  DATA 74,20
019E:  DATA 4F,4E
01A0:  DATA 0A,00
01A2:  DATA 53,65
01A4:  DATA 74,20
01A6:  DATA 4F,46
01A8:  DATA 46,0A
01AA:  DATA 00,00
01AC:  DATA 3E,4C
01AE:  DATA 69,6E
01B0:  DATA 65,20
01B2:  DATA 64,65
01B4:  DATA 6C,61
01B6:  DATA 79,0A
01B8:  DATA 00,00
01BA:  DATA 4C,69
01BC:  DATA 6E,65
01BE:  DATA 20,25
01C0:  DATA 64,20
01C2:  DATA 64,65
01C4:  DATA 6C,61
01C6:  DATA 79,20
01C8:  DATA 25,64
01CA:  DATA 20,73
01CC:  DATA 65,63
01CE:  DATA 20,0A
01D0:  DATA 00,00
01D2:  DATA 53,65
01D4:  DATA 74,20
01D6:  DATA 74,6F
01D8:  DATA 20,31
01DA:  DATA 2D,30
01DC:  DATA 73,65
01DE:  DATA 63,20
01E0:  DATA 32,2D
01E2:  DATA 33,30
01E4:  DATA 73,65
01E6:  DATA 63,20
01E8:  DATA 33,2D
01EA:  DATA 36,30
01EC:  DATA 73,65
01EE:  DATA 63,0A
01F0:  DATA 00,00
01F2:  DATA 31,20
01F4:  DATA 2D,20
01F6:  DATA 6C,69
01F8:  DATA 73,74
01FA:  DATA 0A,00
01FC:  DATA 32,20
01FE:  DATA 2D,20
0200:  DATA 61,64
0202:  DATA 64,20
0204:  DATA 63,61
0206:  DATA 72,64
0208:  DATA 0A,00
020A:  DATA 33,20
020C:  DATA 2D,20
020E:  DATA 72,65
0210:  DATA 6D,6F
0212:  DATA 76,65
0214:  DATA 20,63
0216:  DATA 61,72
0218:  DATA 64,0A
021A:  DATA 00,00
021C:  DATA 25,64
021E:  DATA 20,3A
0220:  DATA 20,25
0222:  DATA 64,0A
0224:  DATA 00,00
0226:  DATA 77,61
0228:  DATA 69,74
022A:  DATA 69,6E
022C:  DATA 67,20
022E:  DATA 66,6F
0230:  DATA 72,20
0232:  DATA 6E,65
0234:  DATA 77,20
0236:  DATA 63,61
0238:  DATA 72,64
023A:  DATA 20,28
023C:  DATA 6F,72
023E:  DATA 20,61
0240:  DATA 6E,79
0242:  DATA 20,6B
0244:  DATA 65,79
0246:  DATA 20,74
0248:  DATA 6F,20
024A:  DATA 61,62
024C:  DATA 6F,72
024E:  DATA 74,29
0250:  DATA 2E,2E
0252:  DATA 2E,2E
0254:  DATA 0A,00
0256:  DATA 43,61
0258:  DATA 72,64
025A:  DATA 20,77
025C:  DATA 61,73
025E:  DATA 20,61
0260:  DATA 64,64
0262:  DATA 65,64
0264:  DATA 20,68
0266:  DATA 65,72
0268:  DATA 65,0A
026A:  DATA 00,00
026C:  DATA 43,61
026E:  DATA 72,64
0270:  DATA 20,25
0272:  DATA 64,20
0274:  DATA 61,64
0276:  DATA 64,65
0278:  DATA 64,20
027A:  DATA 6F,6E
027C:  DATA 20,25
027E:  DATA 64,20
0280:  DATA 70,6C
0282:  DATA 61,63
0284:  DATA 65,0A
0286:  DATA 00,00
0288:  DATA 4E,6F
028A:  DATA 74,20
028C:  DATA 65,6D
028E:  DATA 70,74
0290:  DATA 79,20
0292:  DATA 73,70
0294:  DATA 61,63
0296:  DATA 65,20
0298:  DATA 66,6F
029A:  DATA 72,20
029C:  DATA 6E,65
029E:  DATA 77,20
02A0:  DATA 63,61
02A2:  DATA 72,64
02A4:  DATA 0A,00
02A6:  DATA 25,64
02A8:  DATA 20,3A
02AA:  DATA 20,25
02AC:  DATA 64,0A
02AE:  DATA 00,00
02B0:  DATA 49,64
02B2:  DATA 20,74
02B4:  DATA 6F,20
02B6:  DATA 72,65
02B8:  DATA 6D,6F
02BA:  DATA 76,65
02BC:  DATA 3A,0A
02BE:  DATA 0A,00
02C0:  DATA 72,65
02C2:  DATA 6D,6F
02C4:  DATA 76,65
02C6:  DATA 64,0A
02C8:  DATA 00,00
02CA:  DATA 57,72
02CC:  DATA 6F,6E
02CE:  DATA 67,20
02D0:  DATA 69,64
02D2:  DATA 0A,00
02D4:  DATA 0A,4D
02D6:  DATA 65,73
02D8:  DATA 73,61
02DA:  DATA 67,65
02DC:  DATA 20,54
02DE:  DATA 6F,20
02E0:  DATA 43,41
02E2:  DATA 4E,3A
02E4:  DATA 20,25
02E6:  DATA 64,20
02E8:  DATA 25,64
02EA:  DATA 20,25
02EC:  DATA 64,20
02EE:  DATA 25,64
02F0:  DATA 20,25
02F2:  DATA 64,20
02F4:  DATA 25,64
02F6:  DATA 20,25
02F8:  DATA 64,20
02FA:  DATA 25,64
02FC:  DATA 20,0A
02FE:  DATA 00,00
0300:  DATA 0A,52
0302:  DATA 65,63
0304:  DATA 69,70
0306:  DATA 69,65
0308:  DATA 6E,74
030A:  DATA 20,49
030C:  DATA 64,3A
030E:  DATA 00,00
0310:  DATA 0A,20
0312:  DATA 6D,73
0314:  DATA 67,3A
0316:  DATA 00,00
0318:  DATA 0A,53
031A:  DATA 65,6E
031C:  DATA 64,20
031E:  DATA 79,2F
0320:  DATA 6E,00
0322:  DATA 0A,6F
0324:  DATA 6B,00
0326:  DATA 0A,2D
0328:  DATA 2D,2D
032A:  DATA 2D,2D
032C:  DATA 2D,2D
032E:  DATA 2D,2D
0330:  DATA 43,41
0332:  DATA 4E,20
0334:  DATA 54,4F
0336:  DATA 4F,4C
0338:  DATA 53,2D
033A:  DATA 2D,2D
033C:  DATA 2D,2D
033E:  DATA 2D,2D
0340:  DATA 2D,2D
0342:  DATA 0A,00
0344:  DATA 31,20
0346:  DATA 2D,20
0348:  DATA 64,69
034A:  DATA 73,63
034C:  DATA 6F,76
034E:  DATA 65,72
0350:  DATA 20,64
0352:  DATA 65,76
0354:  DATA 69,63
0356:  DATA 65,73
0358:  DATA 0A,00
035A:  DATA 32,20
035C:  DATA 2D,20
035E:  DATA 73,65
0360:  DATA 6E,64
0362:  DATA 20,6D
0364:  DATA 65,73
0366:  DATA 73,61
0368:  DATA 67,65
036A:  DATA 20,6F
036C:  DATA 6E,20
036E:  DATA 63,61
0370:  DATA 6E,0A
0372:  DATA 00,00
0374:  DATA 3E,64
0376:  DATA 65,76
0378:  DATA 69,63
037A:  DATA 65,73
037C:  DATA 20,6F
037E:  DATA 6E,20
0380:  DATA 43,41
0382:  DATA 4E,3A
0384:  DATA 0A,00
0386:  DATA 3E,4E
0388:  DATA 4F,54
038A:  DATA 20,49
038C:  DATA 4D,50
038E:  DATA 4C,45
0390:  DATA 4D,45
0392:  DATA 4E,54
0394:  DATA 45,44
0396:  DATA 0A,00
0398:  DATA 0A,3E
039A:  DATA 53,6F
039C:  DATA 66,74
039E:  DATA 20,6C
03A0:  DATA 69,67
03A2:  DATA 68,74
03A4:  DATA 20,6D
03A6:  DATA 6F,64
03A8:  DATA 75,6C
03AA:  DATA 61,74
03AC:  DATA 69,6F
03AE:  DATA 6E,20
03B0:  DATA 66,6F
03B2:  DATA 72,20
03B4:  DATA 4C,45
03B6:  DATA 44,00
03B8:  DATA 0A,4C
03BA:  DATA 69,67
03BC:  DATA 68,74
03BE:  DATA 20,73
03C0:  DATA 74,61
03C2:  DATA 74,69
03C4:  DATA 6F,6E
03C6:  DATA 20,49
03C8:  DATA 64,3A
03CA:  DATA 00,00
03CC:  DATA 0A,61
03CE:  DATA 63,74
03D0:  DATA 69,76
03D2:  DATA 61,74
03D4:  DATA 69,6F
03D6:  DATA 6E,20
03D8:  DATA 79,2F
03DA:  DATA 6E,00
03DC:  DATA 0A,6F
03DE:  DATA 6B,00
03E0:  DATA 0A,6C
03E2:  DATA 69,67
03E4:  DATA 68,74
03E6:  DATA 20,6F
03E8:  DATA 6E,20
03EA:  DATA 6D,6F
03EC:  DATA 74,69
03EE:  DATA 6F,6E
03F0:  DATA 20,79
03F2:  DATA 2F,6E
03F4:  DATA 00,00
03F6:  DATA 0A,6F
03F8:  DATA 6B,00
03FA:  DATA 0A,2D
03FC:  DATA 2D,2D
03FE:  DATA 2D,4C
0400:  DATA 49,47
0402:  DATA 48,54
0404:  DATA 53,54
0406:  DATA 41,54
0408:  DATA 49,4F
040A:  DATA 4E,20
040C:  DATA 41,44
040E:  DATA 4D,49
0410:  DATA 4E,2D
0412:  DATA 2D,2D
0414:  DATA 2D,2D
0416:  DATA 0A,00
0418:  DATA 31,20
041A:  DATA 2D,20
041C:  DATA 73,6F
041E:  DATA 66,74
0420:  DATA 20,6C
0422:  DATA 69,67
0424:  DATA 68,74
0426:  DATA 0A,00
0428:  DATA 32,20
042A:  DATA 2D,20
042C:  DATA 6C,69
042E:  DATA 67,68
0430:  DATA 74,20
0432:  DATA 6F,6E
0434:  DATA 20,6D
0436:  DATA 6F,74
0438:  DATA 69,6F
043A:  DATA 6E,0A
043C:  DATA 00,00
043E:  DATA 0A,41
0440:  DATA 6C,61
0442:  DATA 72,6D
0444:  DATA 20,6F
0446:  DATA 6B,0A
0448:  DATA 0A,00
044A:  DATA 75,6E
044C:  DATA 61,72
044E:  DATA 6D,65
0450:  DATA 64,0A
0452:  DATA 00,00
0454:  DATA 3E,6C
0456:  DATA 69,6E
0458:  DATA 65,73
045A:  DATA 20,61
045C:  DATA 75,74
045E:  DATA 6F,20
0460:  DATA 63,6F
0462:  DATA 6E,66
0464:  DATA 69,67
0466:  DATA 0A,00
0468:  DATA 3E,6C
046A:  DATA 69,6E
046C:  DATA 65,73
046E:  DATA 20,63
0470:  DATA 6F,6E
0472:  DATA 66,69
0474:  DATA 67,0A
0476:  DATA 00,00
0478:  DATA 3E,6C
047A:  DATA 69,6E
047C:  DATA 65,73
047E:  DATA 20,6D
0480:  DATA 6F,6E
0482:  DATA 69,74
0484:  DATA 6F,72
0486:  DATA 0A,00
0488:  DATA 3E,73
048A:  DATA 69,72
048C:  DATA 65,6E
048E:  DATA 65,20
0490:  DATA 63,6F
0492:  DATA 6E,66
0494:  DATA 69,67
0496:  DATA 0A,00
0498:  DATA 3E,63
049A:  DATA 61,72
049C:  DATA 64,73
049E:  DATA 0A,00
04A0:  DATA 3E,74
04A2:  DATA 69,6D
04A4:  DATA 65,0A
04A6:  DATA 00,00
04A8:  DATA 3E,61
04AA:  DATA 72,6D
04AC:  DATA 65,64
04AE:  DATA 0A,00
04B0:  DATA 0A,2D
04B2:  DATA 2D,2D
04B4:  DATA 2D,2D
04B6:  DATA 2D,2D
04B8:  DATA 2D,2D
04BA:  DATA 2D,2D
04BC:  DATA 2D,2D
04BE:  DATA 2D,2D
04C0:  DATA 2D,2D
04C2:  DATA 2D,2D
04C4:  DATA 2D,2D
04C6:  DATA 2D,2D
04C8:  DATA 2D,2D
04CA:  DATA 2D,2D
04CC:  DATA 0A,00
04CE:  DATA 4D,61
04D0:  DATA 69,6E
04D2:  DATA 20,6D
04D4:  DATA 65,6E
04D6:  DATA 75,20
04D8:  DATA 61,6C
04DA:  DATA 61,72
04DC:  DATA 6D,20
04DE:  DATA 63,65
04E0:  DATA 6E,74
04E2:  DATA 72,61
04E4:  DATA 6C,0A
04E6:  DATA 00,00
04E8:  DATA 2D,2D
04EA:  DATA 2D,2D
04EC:  DATA 2D,2D
04EE:  DATA 2D,2D
04F0:  DATA 2D,2D
04F2:  DATA 2D,2D
04F4:  DATA 2D,2D
04F6:  DATA 2D,2D
04F8:  DATA 2D,2D
04FA:  DATA 2D,2D
04FC:  DATA 2D,2D
04FE:  DATA 2D,2D
0500:  DATA 2D,2D
0502:  DATA 2D,0A
0504:  DATA 0A,00
0506:  DATA 31,20
0508:  DATA 2D,20
050A:  DATA 6C,69
050C:  DATA 6E,65
050E:  DATA 73,20
0510:  DATA 61,75
0512:  DATA 74,6F
0514:  DATA 20,63
0516:  DATA 6F,6E
0518:  DATA 66,69
051A:  DATA 67,0A
051C:  DATA 00,00
051E:  DATA 32,20
0520:  DATA 2D,20
0522:  DATA 6C,69
0524:  DATA 6E,65
0526:  DATA 73,20
0528:  DATA 63,6F
052A:  DATA 6E,66
052C:  DATA 69,67
052E:  DATA 0A,00
0530:  DATA 33,20
0532:  DATA 2D,20
0534:  DATA 6C,69
0536:  DATA 6E,65
0538:  DATA 73,20
053A:  DATA 6D,6F
053C:  DATA 6E,69
053E:  DATA 74,6F
0540:  DATA 72,0A
0542:  DATA 00,00
0544:  DATA 34,20
0546:  DATA 2D,20
0548:  DATA 73,69
054A:  DATA 72,65
054C:  DATA 6E,65
054E:  DATA 20,63
0550:  DATA 6F,6E
0552:  DATA 66,69
0554:  DATA 67,0A
0556:  DATA 00,00
0558:  DATA 35,20
055A:  DATA 2D,20
055C:  DATA 63,61
055E:  DATA 72,64
0560:  DATA 73,0A
0562:  DATA 00,00
0564:  DATA 36,20
0566:  DATA 2D,20
0568:  DATA 74,69
056A:  DATA 6D,65
056C:  DATA 0A,00
056E:  DATA 37,20
0570:  DATA 2D,20
0572:  DATA 61,72
0574:  DATA 6D,0A
0576:  DATA 00,00
0578:  DATA 38,20
057A:  DATA 2D,20
057C:  DATA 43,41
057E:  DATA 4E,20
0580:  DATA 74,6F
0582:  DATA 6F,6C
0584:  DATA 73,0A
0586:  DATA 00,00
0588:  DATA 39,20
058A:  DATA 2D,20
058C:  DATA 4C,69
058E:  DATA 67,68
0590:  DATA 74,53
0592:  DATA 74,61
0594:  DATA 74,69
0596:  DATA 6F,6E
0598:  DATA 20,61
059A:  DATA 64,6D
059C:  DATA 69,6E
059E:  DATA 0A,00
05A0:  DATA 46,69
05A2:  DATA 72,73
05A4:  DATA 74,20
05A6:  DATA 70,72
05A8:  DATA 65,73
05AA:  DATA 73,20
05AC:  DATA 53,45
05AE:  DATA 54,20
05B0:  DATA 62,75
05B2:  DATA 74,74
05B4:  DATA 6F,6E
05B6:  DATA 20,74
05B8:  DATA 6F,20
05BA:  DATA 64,69
05BC:  DATA 73,61
05BE:  DATA 72,6D
05C0:  DATA 0A,00
05C2:  DATA 0A,4D
05C4:  DATA 65,73
05C6:  DATA 73,61
05C8:  DATA 67,65
05CA:  DATA 20,46
05CC:  DATA 72,6F
05CE:  DATA 6D,20
05D0:  DATA 43,41
05D2:  DATA 4E,3A
05D4:  DATA 20,25
05D6:  DATA 64,20
05D8:  DATA 25,64
05DA:  DATA 20,25
05DC:  DATA 64,20
05DE:  DATA 25,64
05E0:  DATA 20,25
05E2:  DATA 64,20
05E4:  DATA 25,64
05E6:  DATA 20,25
05E8:  DATA 64,20
05EA:  DATA 25,64
05EC:  DATA 20,0A
05EE:  DATA 00,00
05F0:  DATA 61,6C
05F2:  DATA 61,72
05F4:  DATA 6D,20
05F6:  DATA 6F,66
05F8:  DATA 66,20
05FA:  DATA 61,6E
05FC:  DATA 64,20
05FE:  DATA 75,6E
0600:  DATA 61,72
0602:  DATA 6D,65
0604:  DATA 64,0A
0606:  DATA 00,00
0608:  DATA 75,6E
060A:  DATA 61,72
060C:  DATA 6D,65
060E:  DATA 64,0A
0610:  DATA 00,00
0612:  DATA 61,72
0614:  DATA 6D,65
0616:  DATA 64,0A
0618:  DATA 00,00
061A:  DATA 75,6E
061C:  DATA 6B,6E
061E:  DATA 6F,77
0620:  DATA 6E,20
0622:  DATA 63,61
0624:  DATA 72,64
0626:  DATA 0A,00
*
064E:  TBLRD*+
0650:  MOVF   FF5,F
0652:  BZ    066E
0654:  MOVFF  FF6,3B
0658:  MOVFF  FF7,3C
065C:  MOVF   FF5,W
065E:  BTFSS  F9E.4
0660:  BRA    065E
0662:  MOVWF  FAD
0664:  MOVFF  3B,FF6
0668:  MOVFF  3C,FF7
066C:  BRA    064E
066E:  RETURN 0
*
0B1A:  MOVF   3F,W
0B1C:  CLRF   01
0B1E:  SUBWF  3E,W
0B20:  BC    0B28
0B22:  MOVFF  3E,00
0B26:  BRA    0B40
0B28:  CLRF   00
0B2A:  MOVLW  08
0B2C:  MOVWF  40
0B2E:  RLCF   3E,F
0B30:  RLCF   00,F
0B32:  MOVF   3F,W
0B34:  SUBWF  00,W
0B36:  BTFSC  FD8.0
0B38:  MOVWF  00
0B3A:  RLCF   01,F
0B3C:  DECFSZ 40,F
0B3E:  BRA    0B2E
0B40:  RETURN 0
0B42:  MOVLW  20
0B44:  BTFSS  31.4
0B46:  MOVLW  30
0B48:  MOVWF  32
0B4A:  MOVFF  30,00
0B4E:  BTFSS  30.7
0B50:  BRA    0B62
0B52:  COMF   00,F
0B54:  INCF   00,F
0B56:  MOVFF  00,30
0B5A:  MOVLW  2D
0B5C:  MOVWF  32
0B5E:  BSF    31.7
0B60:  BSF    31.0
0B62:  MOVF   01,W
0B64:  MOVFF  30,3E
0B68:  MOVLW  64
0B6A:  MOVWF  3F
0B6C:  RCALL  0B1A
0B6E:  MOVFF  00,30
0B72:  MOVLW  30
0B74:  ADDWF  01,W
0B76:  MOVWF  33
0B78:  MOVFF  30,3E
0B7C:  MOVLW  0A
0B7E:  MOVWF  3F
0B80:  RCALL  0B1A
0B82:  MOVLW  30
0B84:  ADDWF  00,W
0B86:  MOVWF  35
0B88:  MOVLW  30
0B8A:  ADDWF  01,W
0B8C:  MOVWF  34
0B8E:  MOVFF  32,00
0B92:  MOVLW  30
0B94:  SUBWF  33,W
0B96:  BZ    0BA0
0B98:  BSF    31.1
0B9A:  BTFSC  31.7
0B9C:  BSF    31.2
0B9E:  BRA    0BC4
0BA0:  BTFSC  31.2
0BA2:  BRA    0BC4
0BA4:  MOVFF  32,33
0BA8:  BTFSC  31.1
0BAA:  BRA    0BB4
0BAC:  MOVLW  30
0BAE:  SUBWF  34,W
0BB0:  BZ    0BBA
0BB2:  BSF    31.0
0BB4:  BTFSC  31.7
0BB6:  BSF    31.1
0BB8:  BRA    0BC4
0BBA:  BTFSS  FD8.2
0BBC:  BSF    31.0
0BBE:  BTFSC  FD8.2
0BC0:  MOVFF  33,34
0BC4:  BTFSC  31.2
0BC6:  BRA    0BD2
0BC8:  BTFSC  31.1
0BCA:  BRA    0BDA
0BCC:  BTFSC  31.0
0BCE:  BRA    0BE2
0BD0:  BRA    0BEA
0BD2:  MOVF   32,W
0BD4:  BTFSS  F9E.4
0BD6:  BRA    0BD4
0BD8:  MOVWF  FAD
0BDA:  MOVF   33,W
0BDC:  BTFSS  F9E.4
0BDE:  BRA    0BDC
0BE0:  MOVWF  FAD
0BE2:  MOVF   34,W
0BE4:  BTFSS  F9E.4
0BE6:  BRA    0BE4
0BE8:  MOVWF  FAD
0BEA:  MOVF   35,W
0BEC:  BTFSS  F9E.4
0BEE:  BRA    0BEC
0BF0:  MOVWF  FAD
0BF2:  RETURN 0
0BF4:  TBLRD*+
0BF6:  MOVFF  FF6,39
0BFA:  MOVFF  FF7,3A
0BFE:  MOVF   FF5,W
0C00:  BTFSS  F9E.4
0C02:  BRA    0C00
0C04:  MOVWF  FAD
0C06:  MOVFF  39,FF6
0C0A:  MOVFF  3A,FF7
0C0E:  DECFSZ 38,F
0C10:  BRA    0BF4
0C12:  RETURN 0
*
0DF8:  MOVLW  20
0DFA:  BTFSS  39.4
0DFC:  MOVLW  30
0DFE:  MOVWF  3A
0E00:  MOVFF  38,00
0E04:  BTFSS  38.7
0E06:  BRA    0E18
0E08:  COMF   00,F
0E0A:  INCF   00,F
0E0C:  MOVFF  00,38
0E10:  MOVLW  2D
0E12:  MOVWF  3A
0E14:  BSF    39.7
0E16:  BSF    39.0
0E18:  MOVF   01,W
0E1A:  MOVFF  38,3E
0E1E:  MOVLW  64
0E20:  MOVWF  3F
0E22:  RCALL  0B1A
0E24:  MOVFF  00,38
0E28:  MOVLW  30
0E2A:  ADDWF  01,W
0E2C:  MOVWF  3B
0E2E:  MOVFF  38,3E
0E32:  MOVLW  0A
0E34:  MOVWF  3F
0E36:  RCALL  0B1A
0E38:  MOVLW  30
0E3A:  ADDWF  00,W
0E3C:  MOVWF  3D
0E3E:  MOVLW  30
0E40:  ADDWF  01,W
0E42:  MOVWF  3C
0E44:  MOVFF  3A,00
0E48:  MOVLW  30
0E4A:  SUBWF  3B,W
0E4C:  BZ    0E56
0E4E:  BSF    39.1
0E50:  BTFSC  39.7
0E52:  BSF    39.2
0E54:  BRA    0E7A
0E56:  MOVFF  3A,3B
0E5A:  MOVLW  20
0E5C:  MOVWF  3A
0E5E:  MOVLW  30
0E60:  SUBWF  3C,W
0E62:  BZ    0E6C
0E64:  BSF    39.0
0E66:  BTFSC  39.7
0E68:  BSF    39.1
0E6A:  BRA    0E7A
0E6C:  BTFSS  FD8.2
0E6E:  BSF    39.0
0E70:  BNZ   0E7A
0E72:  MOVFF  3B,3C
0E76:  MOVLW  20
0E78:  MOVWF  3B
0E7A:  BTFSC  39.2
0E7C:  BRA    0E88
0E7E:  BTFSC  39.1
0E80:  BRA    0E90
0E82:  BTFSC  39.0
0E84:  BRA    0E98
0E86:  BRA    0EA0
0E88:  MOVF   3A,W
0E8A:  BTFSS  F9E.4
0E8C:  BRA    0E8A
0E8E:  MOVWF  FAD
0E90:  MOVF   3B,W
0E92:  BTFSS  F9E.4
0E94:  BRA    0E92
0E96:  MOVWF  FAD
0E98:  MOVF   3C,W
0E9A:  BTFSS  F9E.4
0E9C:  BRA    0E9A
0E9E:  MOVWF  FAD
0EA0:  MOVF   3D,W
0EA2:  BTFSS  F9E.4
0EA4:  BRA    0EA2
0EA6:  MOVWF  FAD
0EA8:  RETURN 0
*
124A:  ADDWF  FE8,W
124C:  CLRF   FF7
124E:  RLCF   FF7,F
1250:  ADDLW  65
1252:  MOVWF  FF6
1254:  MOVLW  12
1256:  ADDWFC FF7,F
1258:  TBLRD*-
125A:  MOVF   FF5,W
125C:  MOVWF  FFA
125E:  TBLRD*
1260:  MOVF   FF5,W
1262:  MOVWF  FF9
1264:  DATA BA,11
1266:  DATA D6,11
1268:  DATA F2,11
126A:  DATA 0E,12
126C:  DATA 2A,12
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, NOPROTECT, PUT, BROWNOUT, NOWDT 
.................... #use delay(clock=8000000)  
*
0628:  CLRF   FEA
062A:  MOVLW  30
062C:  MOVWF  FE9
062E:  MOVF   FEF,W
0630:  BZ    064C
0632:  MOVLW  02
0634:  MOVWF  01
0636:  CLRF   00
0638:  DECFSZ 00,F
063A:  BRA    0638
063C:  DECFSZ 01,F
063E:  BRA    0636
0640:  MOVLW  97
0642:  MOVWF  00
0644:  DECFSZ 00,F
0646:  BRA    0644
0648:  DECFSZ FEF,F
064A:  BRA    0632
064C:  RETURN 0
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, ERRORS)  
*
126E:  BTFSS  F9E.5
1270:  BRA    126E
1272:  MOVFF  FAB,04
1276:  MOVFF  FAE,01
127A:  BTFSS  04.1
127C:  BRA    1282
127E:  BCF    FAB.4
1280:  BSF    FAB.4
1282:  RETURN 0
....................  
.................... ///--------LINES DEFINES---------- 
.................... #define DEF_LINE_STATE 0 // domyslny stan na linii czujek, przeciwny jest alarmem 
.................... #define L1 PIN_A0 
.................... #define L2 PIN_A1 
.................... #define L3 PIN_A2 
.................... #define L4 PIN_A3 
....................  
.................... ///--------SIRENE DEFINE--------- 
.................... #define SIR PIN_C0 
....................  
.................... ///--------BUTTON DEFINE-------- 
.................... #define SET PIN_B1 
....................  
.................... //---------LED DEFINE------------ 
.................... #define LED_GREEN PIN_A7 
.................... #define LED_RED   PIN_A6 
....................  
.................... ///--------DEVICE STATE DEFINES---- 
.................... #define st_unarmed     0 
.................... #define st_armed       1 
.................... #define st_alarm       2 
.................... #define st_postalarm  3 
....................  
....................  
.................... ///--------CAN DEFINES---------- 
.................... #include <can-18F4580.c>  // Use correct driver  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18F4580.c                            //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18F4580 CAN peripheral*         //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers*         //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode*     //// 
.................... ////                                                                 //// 
.................... ////     can_set_functional_mode - Sets the function mode            //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID*              //// 
.................... ////                                                                 //// 
.................... ////     can_set_extended_id - Sets only extended ID                 //// 
.................... ////                                                                 //// 
.................... ////     can_set_standard_id - Sets only standard ID                 //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID*              //// 
.................... ////                                                                 //// 
.................... ////     can_get_extended_id - Gets only extended ID                 //// 
.................... ////                                                                 //// 
.................... ////     can_get_standard_id - Gets only standard ID                 //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID*        //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specified message/request and ID*         //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the*     //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data*                                    //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions*                //// 
.................... ////                                                                 //// 
.................... ////    can_enable_b_transfer - enables buffer as transmitter        //// 
.................... ////                                                                 //// 
.................... ////     can_enable_b_receiver - enables buffer as receiver          //// 
.................... ////                                                                 //// 
.................... ////     can_enable_rtr - enables transmit buffer as Auto-rtr        //// 
.................... ////                                                                 //// 
.................... ////     can_disable_rtr - disables transmit buffer as Auto-rtr      //// 
.................... ////                                                                 //// 
.................... ////    can_load_rtr - loads an Auto-rtr buffer with data            //// 
.................... ////                                                                 //// 
.................... ////    can_enable_filter - enables one of 15 filters                //// 
.................... ////                                                                 //// 
.................... ////    can_disable_filter - disables one of the 15 filters          //// 
.................... ////                                                                 //// 
.................... ////    can_associate_filter_to_buffer - associates a filter with    //// 
.................... ////                                      a receive buffer           //// 
.................... ////                                                                 //// 
.................... ////     can_associate_filter_to_mask - associates a filter with a   //// 
.................... ////                                    mask                         //// 
.................... ////                                                                 //// 
.................... ////     can_fifo_getd - retrieve data in FIFO mode (2)              //// 
.................... ////                                                                 //// 
.................... ////     can_t0_putd                                                 //// 
.................... ////     can_t1_putd                                                 //// 
.................... ////     can_t2_putd                                                 //// 
.................... ////     can_b0_putd                                                 //// 
.................... ////     can_b1_putd                                                 //// 
.................... ////     can_b2_putd                                                 //// 
.................... ////     can_b3_putd                                                 //// 
.................... ////     can_b4_putd                                                 //// 
.................... ////     can_b5_putd                                                 //// 
.................... ////     can_b6_putd                                                 //// 
.................... ////     can_b7_putd - place data in a specific buffer               //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transceiver to connect these pins to CANH and CANL bus lines.   //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... //// * Designates functions that work in legacy mode                 //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  Sep 29 09 - fixed problems with enhanced mode                  //// 
.................... ////                                                                 //// 
.................... ////  Oct 08 09 - can_getd() filter hit fixed of enhanced mode       //// 
.................... ////                                                                 //// 
.................... ////  Jan 21 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 13 10 - changed can_set_functional_mode() to restore       //// 
.................... ////              operating mode to same mode when called, instead   //// 
.................... ////              of setting it to normal mode                       //// 
.................... ////                                                                 //// 
.................... ////  Mar 24 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ////  Jan 10 13 - Fixed an issue with can_associate_filter_to_mask() //// 
.................... ////              and can_associate_filter_to_buffer() functions     //// 
.................... ////              using incorrect register addresses for K80 chips,  //// 
.................... ////              and updated can_init() function to setup correct   //// 
.................... ////              tris register for PIC being used.                  //// 
.................... ////                                                                 //// 
.................... ////  Oct 03 13 - Updated can_getd() and can_fifo_getd() functions   //// 
.................... ///               to clear overflow flag when in mode 1 and 2.       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18F4580.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18F4580.h                            //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18F4580.c)                                             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18F4580_LIB_DEFINES__ 
.................... #define __CCS_CAN18F4580_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////  CAN Control Register ///////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_OP_MODE {   CAN_OP_CONFIG=4, 
....................                      CAN_OP_LISTEN=3, 
....................                      CAN_OP_LOOPBACK=2, 
....................                      CAN_OP_DISABLE=1, 
....................                      CAN_OP_NORMAL=0 }; 
....................  
.................... enum CAN_FUN_OP_MODE { CAN_FUN_OP_LEGACY=0, 
....................                        CAN_FUN_OP_ENHANCED=1, 
....................                        CAN_FUN_OP_ENHANCED_FIFO=2 }; 
....................  
.................... enum CAN_WIN_ADDRESS {   CAN_WIN_RX0=0, 
....................                         CAN_WIN_RX1=5, 
....................                         CAN_WIN_TX0=4, 
....................                         CAN_WIN_TX1=3, 
....................                         CAN_WIN_TX2=2 }; 
....................  
.................... enum CAN_FIFO_READ {   CAN_FIFO_MB7=7, 
....................                      CAN_FIFO_MB6=6, 
....................                      CAN_FIFO_MB5=5, 
....................                      CAN_FIFO_MB4=4, 
....................                      CAN_FIFO_MB3=3, 
....................                      CAN_FIFO_MB2=2, 
....................                      CAN_FIFO_MB1=1, 
....................                      CAN_FIFO_MB0=0 }; 
....................  
.................... // Control register configurations for modes 0, 1, and 2 
.................... //can control 
.................... struct { 
....................    int1 void0;              //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3   //window address bits 
....................    int1 abat;               //4     //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;     //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")    //0xF6F 
....................  
.................... //can control for mode 1 
.................... struct { 
....................    int1 void3210:4;     //0123 
....................    int1 abat;           //4    abort all pending transmissions 
....................    CAN_OP_MODE reqop:3; //5:7  request can operation mode bits 
.................... } CANCON_MODE_1; 
.................... #byte CANCON_MODE_1 = getenv("SFR:CANCON")      //0xF6F 
....................  
.................... // can control for mode 2 
.................... struct { 
....................    CAN_FIFO_READ fp:4;  //0:3 points to message buffer to read 
....................    int1 abat;           //4   abort 
....................    CAN_OP_MODE reqop:3; //5:7 request can operation mode bits 
.................... } CANCON_MODE_2; 
.................... #byte CANCON_MODE_2 = getenv("SFR:CANCON")      //0xF6F 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////  ECAN control register /////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum ECAN_MODE { ECAN_LEGACY=0, ECAN_ENHANCED_LEGACY=1, ECAN_ENHANCED_FIFO=2 }; 
.................... enum ECAN_WINDOW_ADDRESS { AF012_BRGCON23=0, 
....................                            AF345_BRGCON1_=1, 
....................                            AFM_ERROR_ICON=2, 
....................                            TX0=3, 
....................                            TX1=4, 
....................                            TX2=5, 
....................                            AF678=6, 
....................                            AccF91011=7, 
....................                            AccF121314=8, 
....................                            AccF15=9, 
....................                            RXINT01=15, 
....................                            RX0=16, 
....................                            RX1=17, 
....................                            TXRX0=18, 
....................                            TXRX1=19, 
....................                            TXRX2=20, 
....................                            TXRX3=21, 
....................                            TXRX4=22, 
....................                            TXRX5=23 }; 
....................  
.................... //ecan control register mode 1, 2, & 3 
.................... struct { 
....................    ECAN_WINDOW_ADDRESS ewin:5;   //0:4 access bank map 
....................    int1 fifowm;                  //5   FIFO high water mark 
....................    ECAN_MODE mdsel:2;            //6:7 Mode select bits 
.................... } ECANCON; 
.................... #byte ECANCON = getenv("SFR:ECANCON")     //0xF77 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////  CAN Status Register  /////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_INT_CODE {   CAN_INT_WAKEUP=7, 
....................                      CAN_INT_RX0=6, 
....................                      CAN_INT_RX1=5, 
....................                      CAN_INT_TX0=4, 
....................                      CAN_INT_TX1=3, 
....................                      CAN_INT_TX2=2, 
....................                      CAN_INT_ERROR=1, 
....................                      CAN_INT_NO=0}; 
....................  
.................... enum CAN_EINT_CODE {   CAN_EINT_NO=0, 
....................                      CAN_EINT_ERROR=2, 
....................                      CAN_EINT_TX2=4, 
....................                      CAN_EINT_TX1=6, 
....................                      CAN_EINT_TX0=8, 
....................                      CAN_EINT_RX1=17, 
....................                      CAN_EINT_RX0=16, 
....................                      CAN_EINT_WAKEUP=14, 
....................                      CAN_EINT_RXB0=16, 
....................                      CAN_EINT_RXB1=17, 
....................                      CAN_EINT_B0=18, 
....................                      CAN_EINT_B1=19, 
....................                      CAN_EINT_B2=20, 
....................                      CAN_EINT_B3=21, 
....................                      CAN_EINT_B4=22, 
....................                      CAN_EINT_B5=23 }; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;             //0 
....................    CAN_INT_CODE icode:3;   //1:3 //interrupt code 
....................    int1 void4;             //4 
....................    CAN_OP_MODE opmode:3;   //5:7 //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")     //0xF6E 
....................  
.................... //can status register mode 1 
.................... struct { 
....................    CAN_EINT_CODE eicode:5;   //0:4 interrupt code 
....................    CAN_OP_MODE opmode:3;     //5:7 operation mode status 
.................... } CANSTAT_MODE_1; 
.................... #byte CANSTAT_MODE_1 = getenv("SFR:CANSTAT")    //0xF6E 
....................  
.................... //can status register mode 2 
.................... struct { 
....................    CAN_EINT_CODE eicode:5; 
....................    CAN_OP_MODE opmode:3; 
.................... }   CANSTAT_MODE_2; 
.................... #byte CANSTAT_MODE_2 = getenv("SFR:CANSTAT")    //0xF6E 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////  Communication Status Register  /////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;   //0 //error warning 
....................    int1 rxwarn;  //1 //receiver warning 
....................    int1 txwarn;  //2 //transmitter warning 
....................    int1 rxbp;    //3 //receiver bus passive 
....................    int1 txbp;    //4 //transmitter bus passive bit 
....................    int1 txbo;    //5 //transmitter bus off 
....................    int1 rx1ovfl; //6 //receive buffer 1 overflow 
....................    int1 rx0ovfl; //7 //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT = getenv("SFR:COMSTAT")     //0xF74 
....................  
.................... //communication status register mode 1 
.................... struct { 
....................    int1 ewarn;   //0 error warning 
....................    int1 rxwarn;  //1 receiver warning 
....................    int1 txwarn;  //2 transmitter warning 
....................    int1 rxbp;    //3 receiver bus passive 
....................    int1 txbp;    //4 transmitter bus passive bit 
....................    int1 txbo;    //5 transmitter bus off 
....................    int1 rxnovfl; //6 receive buffer n overflow 
....................    int1 void7;   //7 
.................... } COMSTAT_MODE_1; 
.................... #byte COMSTAT_MODE_1 = getenv("SFR:COMSTAT")       //0xF74 
....................  
.................... //communication status register mode 2 
.................... struct { 
....................    int1 ewarn;     //0 error warning 
....................    int1 rxwarn;    //1 receiver warning 
....................    int1 txwarn;    //2 transmitter warning 
....................    int1 rxbp;      //3 receiver bus passive 
....................    int1 txbp;      //4 transmitter bus passive bit 
....................    int1 txbo;      //5 transmitter bus off 
....................    int1 rxnovfl;   //6 receive buffer n overflow 
....................    int1 fifoempty; //7 FIFO not empty bit 
.................... } COMSTAT_MODE_2; 
.................... #byte COMSTAT_MODE_2 = getenv("SFR:COMSTAT")       //0xF74 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// Baud Control Registers ///////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5 //baud rate prescalar 
....................    int sjw:2;   //6:7 //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")     //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3;   //0:2 //propagation time select 
....................    int seg1ph:3;  //3:5 //phase segment 1 
....................    int1 sam;      //6   //sample of the can bus line 
....................    int1 seg2phts; //7   //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")     //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;  //0:2 //phase segment 2 time select 
....................    int void543:3; //3:5 
....................    int1 wakfil;   //6   //selects can bus line filter for wake-up 
....................    int1 void7;    //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")     //0xF72 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;  //0:3 
....................    int1 cancap;     //4 //can message receive capture 
....................    int1 endrhi;     //5 //enable drive high 
....................    int1 tx2en;      //6 //CANTX2 pin enable bit          //added 3/24/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;     //7 //CANTX2 pin data source bit     //added 3/24/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// Transmit Control Registers ///////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //transmit buffer n control register for mode 0 
.................... struct txbNcon_struct { 
....................    int  txpri:2;  //0:1 //transmit priority bits 
....................    int1 void2;    //2 
....................    int1 txreq;    //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;    //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;    //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON = 0xF60 //txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n control register for mode 1 & 2 
.................... struct txbNconm12_struct { 
....................    int  txpri:2;  //0:1 transmit priority bits 
....................    int1 void2;    //2 
....................    int1 txreq;    //3   transmit request status (clear to request message abort) 
....................    int1 txerr;    //4   transmission error detected 
....................    int1 txlarb;   //5   transmission lost arbitration status 
....................    int1 txabt;    //6   transmission aborted status 
....................    int1 txbif;    //7   transmission complete, ready for new data 
.................... }; 
.................... struct txbNconm12_struct TXB0CON_MODE_1; 
.................... struct txbNconm12_struct TXB0CON_MODE_2; 
.................... struct txbNconm12_struct TXB1CON_MODE_1; 
.................... struct txbNconm12_struct TXB1CON_MODE_2; 
.................... struct txbNconm12_struct TXB2CON_MODE_1; 
.................... struct txbNconm12_struct TXB2CON_MODE_2; 
.................... struct txbNconm12_struct TXBaCON_MODE_1; 
.................... struct txbNconm12_struct TXBaCON_MODE_2; 
.................... #byte TXB0CON_MODE_1 = getenv("SFR:TXB0CON")     //0xF40 
.................... #byte TXB0CON_MODE_2 = getenv("SFR:TXB0CON")     //0xF40 
.................... #byte TXB1CON_MODE_1 = getenv("SFR:TXB1CON")     //0xF30 
.................... #byte TXB1CON_MODE_2 = getenv("SFR:TXB1CON")     //0xF30 
.................... #byte TXB2CON_MODE_1 = getenv("SFR:TXB2CON")     //0xF20 
.................... #byte TXB2CON_MODE_2 = getenv("SFR:TXB2CON")     //0xF20 
.................... #byte TXBaCON_MODE_1=0xF60 
.................... #byte TXBaCON_MODE_2=0xF60 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      //0xF41 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      //0xF42 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      //0xF31 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      //0xF32 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      //0xF21 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      //0xF22 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //txb2eidl 
.................... #define B0ID         getenv("SFR:B0EIDL")       //0xE24    //b0eidl 
.................... #define B1ID         getenv("SFR:B1EIDL")       //0xE34    //b1eidl 
.................... #define B2ID         getenv("SFR:B2EIDL")       //0xE44    //b2eidl 
.................... #define B3ID         getenv("SFR:B3EIDL")       //0xE54    //b3eidl 
.................... #define B4ID         getenv("SFR:B4EIDL")       //0xE64    //b4eidl 
.................... #define B5ID         getenv("SFR:B5EIDL")       //0xE74    //b5eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;    //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr;     //6 //transmission frame remote transmission 
....................    int1 void7;   //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT = getenv("SFR:TXERRCNT")      //0xF76 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////// Receive Control Registers ///////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
.................... enum ECAN_FILTER_HIT {   RXF0=0, RXF1=1, RXF2=2, RXF3=3, RXF4=4, RXF5=5, 
....................                         RXF6=6, RXF7=7, RXF8=8, RXF9=9, RXF10=10, RXF11=11, 
....................                         RXF12=12, RXF13=13, RXF14=14, RXF15=15 }; 
....................  
....................  
.................... //receive buffer 0 control register mode 0 
.................... struct { 
....................    int1 filthit0;      //0   //filter hit 
....................    int1 jtoff;         //1   //jump table offset 
....................    int1 rxb0dben;      //2   //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;       //3   //receive remote transfer request 
....................    int1 void4;         //4 
....................    CAN_RX_MODE rxm:2;  //5:6 //receiver buffer mode 
....................    int1 rxful;         //7   //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 0 control register mode 1 & 2 
.................... struct rxb01m12con { 
....................    ECAN_FILTER_HIT filthit:5; //1:4 Acceptance filter bits 
....................    int1 rtrro;                //5   remote transmission request bit 
....................    int1 rxm1;                 //6   receive buffer mode 
....................    int1 rxful;                //7   receive full status 
.................... }; 
.................... struct rxb01m12con RXB0CON_MODE_1; 
.................... struct rxb01m12con RXB0CON_MODE_2; 
.................... #byte RXB0CON_MODE_1 = getenv("SFR:RXB0CON")    //0xF60 
.................... #byte RXB0CON_MODE_2 = getenv("SFR:RXB0CON")    //0xF60 
....................  
.................... //receive buffer 1 control register mode 0 
.................... struct { 
....................    int filthit:3;     //0:2 
....................    int1 rxrtrro;      //3   //receive remote transfer request 
....................    int1 void4;        //4 
....................    CAN_RX_MODE rxm:2; //5:6 //receive buffer mode 
....................    int1 rxful;        //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")      //0xF50 
....................  
.................... //receive buffer 1 control register mode 1 & 2 
.................... struct rxb01m12con RXB1CON_MODE_1; 
.................... struct rxb01m12con RXB1CON_MODE_2; 
.................... #byte RXB1CON_MODE_1 = getenv("SFR:RXB1CON")    //0xF50 
.................... #byte RXB1CON_MODE_2 = getenv("SFR:RXB1CON")    //0xF50 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// Buffer Select Register ///////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum PROG_BUFFER { B0=0x04 , B1=0x08 , B2=0x10 , B3=0x20 , B4=0x40 , B5=0x80 }; 
....................  
.................... // bsel0 
.................... struct { 
....................    int   void10:2;      //0-1 
....................    int1  b0txen;        //2   //buffer 0 transmit enable bit 
....................    int1  b1txen;        //3   //buffer 1 transmit enable bit 
....................    int1  b2txen;        //4   //buffer 2 transmit enable bit 
....................    int1  b3txen;        //5   //buffer 3 transmit enable bit 
....................    int1  b4txen;        //6   //buffer 4 transmit enable bit 
....................    int1  b5txen;        //7   //buffer 5 transmit enable bit 
.................... } BSEL0; 
.................... #byte BSEL0 = getenv("SFR:BSEL0")      //0xDF8 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// Bn Control Registers /////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum ECAN_AF { AF0=0  , AF1=1  , AF2=2  , AF3=3  , AF4=4 , 
....................                AF5=5  , AF6=6  , AF7=7  , AF8=8  , AF9=9 , 
....................                AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, 
....................                AF15=15 }; 
....................  
.................... //Bn control register in receive mode 
.................... struct BaCON_recive { 
....................    ECAN_AF filhit:5; //0:4 Acceptance filter bits 
....................    int1 rxrtrro;     //5   Read only remote transmission request 
....................    int1 rxm1;        //6   Receive buffer mode bit 
....................    int1 rxful;       //7   receiver full status bit 
.................... }; 
....................  
.................... //Bn control register in transmit mode 
.................... struct BaCON_transmit { 
....................    int    txpri:2; //0:1 Priority Bits 
....................    int1   rtren;   //2   Automatic Remote Transmission request bit 
....................    int1   txreq;   //3   Transmit request status 
....................    int1   txerr;   //4   Transmission error detected 
....................    int1   txlarb;  //5   Transmission lost arbitration bit 
....................    int1   txabt;   //6   Transmission aborted status bit 
....................    int1   txbif;   //7   Transmit buffer interrupt flag bit 
.................... }; 
....................  
.................... struct BaCON_recive B0CONR; 
.................... struct BaCON_recive B1CONR; 
.................... struct BaCON_recive B2CONR; 
.................... struct BaCON_recive B3CONR; 
.................... struct BaCON_recive B4CONR; 
.................... struct BaCON_recive B5CONR; 
.................... // struct bytes, used for access to specific bits 
.................... #byte B0CONR = getenv("SFR:B0CON")     //0xE20 
.................... #byte B1CONR = getenv("SFR:B1CON")     //0xE30 
.................... #byte B2CONR = getenv("SFR:B2CON")     //0xE40 
.................... #byte B3CONR = getenv("SFR:B3CON")     //0xE50 
.................... #byte B4CONR = getenv("SFR:B4CON")     //0xE60 
.................... #byte B5CONR = getenv("SFR:B5CON")     //0xE70 
.................... // access bytes, used for fast access to the entire byte 
.................... #byte B0CONRA = getenv("SFR:B0CON")    //0xE20 
.................... #byte B1CONRA = getenv("SFR:B1CON")    //0xE30 
.................... #byte B2CONRA = getenv("SFR:B2CON")    //0xE40 
.................... #byte B3CONRA = getenv("SFR:B3CON")    //0xE50 
.................... #byte B4CONRA = getenv("SFR:B4CON")    //0xE60 
.................... #byte B5CONRA = getenv("SFR:B5CON")    //0xE70 
....................  
.................... struct BaCON_transmit B0CONT; 
.................... struct BaCON_transmit B1CONT; 
.................... struct BaCON_transmit B2CONT; 
.................... struct BaCON_transmit B3CONT; 
.................... struct BaCON_transmit B4CONT; 
.................... struct BaCON_transmit B5CONT; 
.................... // struct bytes, used for access to specific bits 
.................... #byte B0CONT = getenv("SFR:B0CON")     //0xE20 
.................... #byte B1CONT = getenv("SFR:B1CON")     //0xE30 
.................... #byte B2CONT = getenv("SFR:B2CON")     //0xE40 
.................... #byte B3CONT = getenv("SFR:B3CON")     //0xE50 
.................... #byte B4CONT = getenv("SFR:B4CON")     //0xE60 
.................... #byte B5CONT = getenv("SFR:B5CON")     //0xE70 
.................... // access bytes, used for fast access to the entire byte 
.................... #byte B0CONTA = getenv("SFR:B0CON")    //0xE20 
.................... #byte B1CONTA = getenv("SFR:B1CON")    //0xE30 
.................... #byte B2CONTA = getenv("SFR:B2CON")    //0xE40 
.................... #byte B3CONTA = getenv("SFR:B3CON")    //0xE50 
.................... #byte B4CONTA = getenv("SFR:B4CON")    //0xE60 
.................... #byte B5CONTA = getenv("SFR:B5CON")    //0xE70 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// B Data Length Code Registers /////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //DLC register for Bn in receive mode 
.................... struct BnDLC_receive { 
....................    int  dlc:4;    //0:3 data length code bits 
....................    int  void45:2; //4:5 
....................    int1 rxrtr;    //6   receiver remote transmission request 
....................    int1 void7;    //7 
.................... }; 
....................  
.................... //DLC register for Bn in transmit mode 
.................... struct BnDLC_transmit { 
....................    int  dlc:4;    //0:3 data length code bits 
....................    int  void45:2; //4:5 
....................    int1 txrtr;    //6   data length code bits 
....................    int1 void7;    //7 
.................... }; 
....................  
.................... struct BnDLC_receive B0DLCR; 
.................... struct BnDLC_receive B1DLCR; 
.................... struct BnDLC_receive B2DLCR; 
.................... struct BnDLC_receive B3DLCR; 
.................... struct BnDLC_receive B4DLCR; 
.................... struct BnDLC_receive B5DLCR; 
.................... #byte B0DLCR = getenv("SFR:B0DLC")     //0xE25 
.................... #byte B1DLCR = getenv("SFR:B1DLC")     //0xE35 
.................... #byte B2DLCR = getenv("SFR:B2DLC")     //0xE45 
.................... #byte B3DLCR = getenv("SFR:B3DLC")     //0xE55 
.................... #byte B4DLCR = getenv("SFR:B4DLC")     //0xE65 
.................... #byte B5DLCR = getenv("SFR:B5DLC")     //0xE75 
....................  
.................... struct BnDLC_transmit B0DLCT; 
.................... struct BnDLC_transmit B1DLCT; 
.................... struct BnDLC_transmit B2DLCT; 
.................... struct BnDLC_transmit B3DLCT; 
.................... struct BnDLC_transmit B4DLCT; 
.................... struct BnDLC_transmit B5DLCT; 
.................... #byte B0DLCT = getenv("SFR:B0DLC")     //0xE25 
.................... #byte B1DLCT = getenv("SFR:B1DLC")     //0xE35 
.................... #byte B2DLCT = getenv("SFR:B2DLC")     //0xE45 
.................... #byte B3DLCT = getenv("SFR:B3DLC")     //0xE55 
.................... #byte B4DLCT = getenv("SFR:B4DLC")     //0xE65 
.................... #byte B5DLCT = getenv("SFR:B5DLC")     //0xE75 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// General Purpose Buffers //////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #byte B5D7 = getenv("SFR:B5D7")     //0xE7D 
.................... #byte B5D6 = getenv("SFR:B5D6")     //0xE7C 
.................... #byte B5D5 = getenv("SFR:B5D5")     //0xE7B 
.................... #byte B5D4 = getenv("SFR:B5D4")     //0xE7A 
.................... #byte B5D3 = getenv("SFR:B5D3")     //0xE79 
.................... #byte B5D2 = getenv("SFR:B5D2")     //0xE78 
.................... #byte B5D1 = getenv("SFR:B5D1")     //0xE77 
.................... #byte B5D0 = getenv("SFR:B5D0")     //0xE76 
....................  
.................... #byte B4D7 = getenv("SFR:B4D7")     //0xE6D 
.................... #byte B4D6 = getenv("SFR:B4D6")     //0xE6C 
.................... #byte B4D5 = getenv("SFR:B4D5")     //0xE6B 
.................... #byte B4D4 = getenv("SFR:B4D4")     //0xE6A 
.................... #byte B4D3 = getenv("SFR:B4D3")     //0xE69 
.................... #byte B4D2 = getenv("SFR:B4D2")     //0xE68 
.................... #byte B4D1 = getenv("SFR:B4D1")     //0xE67 
.................... #byte B4D0 = getenv("SFR:B4D0")     //0xE66 
....................  
.................... #byte B3D7 = getenv("SFR:B3D7")     //0xE5D 
.................... #byte B3D6 = getenv("SFR:B3D6")     //0xE5C 
.................... #byte B3D5 = getenv("SFR:B3D5")     //0xE5B 
.................... #byte B3D4 = getenv("SFR:B3D4")     //0xE5A 
.................... #byte B3D3 = getenv("SFR:B3D3")     //0xE59 
.................... #byte B3D2 = getenv("SFR:B3D2")     //0xE58 
.................... #byte B3D1 = getenv("SFR:B3D1")     //0xE57 
.................... #byte B3D0 = getenv("SFR:B3D0")     //0xE56 
....................  
.................... #byte B2D7 = getenv("SFR:B2D7")     //0xE4D 
.................... #byte B2D6 = getenv("SFR:B2D6")     //0xE4C 
.................... #byte B2D5 = getenv("SFR:B2D5")     //0xE4B 
.................... #byte B2D4 = getenv("SFR:B2D4")     //0xE4A 
.................... #byte B2D3 = getenv("SFR:B2D3")     //0xE49 
.................... #byte B2D2 = getenv("SFR:B2D2")     //0xE48 
.................... #byte B2D1 = getenv("SFR:B2D1")     //0xE47 
.................... #byte B2D0 = getenv("SFR:B2D0")     //0xE46 
....................  
.................... #byte B1D7 = getenv("SFR:B1D7")     //0xE3D 
.................... #byte B1D6 = getenv("SFR:B1D6")     //0xE3C 
.................... #byte B1D5 = getenv("SFR:B1D5")     //0xE3B 
.................... #byte B1D4 = getenv("SFR:B1D4")     //0xE3A 
.................... #byte B1D3 = getenv("SFR:B1D3")     //0xE39 
.................... #byte B1D2 = getenv("SFR:B1D2")     //0xE38 
.................... #byte B1D1 = getenv("SFR:B1D1")     //0xE37 
.................... #byte B1D0 = getenv("SFR:B1D0")     //0xE36 
....................  
.................... #byte B0D7 = getenv("SFR:B0D7")     //0xE2D 
.................... #byte B0D6 = getenv("SFR:B0D6")     //0xE2C 
.................... #byte B0D5 = getenv("SFR:B0D5")     //0xE2B 
.................... #byte B0D4 = getenv("SFR:B0D4")     //0xE2A 
.................... #byte B0D3 = getenv("SFR:B0D3")     //0xE29 
.................... #byte B0D2 = getenv("SFR:B0D2")     //0xE28 
.................... #byte B0D1 = getenv("SFR:B0D1")     //0xE27 
.................... #byte B0D0 = getenv("SFR:B0D0")     //0xE26 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////// General Purpose Buffer ID Registers /////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // standard Identifier bytes 
.................... #byte B0SIDH = getenv("SFR:B0SIDH")    //0xE21 
.................... #byte B1SIDH = getenv("SFR:B1SIDH")    //0xE31 
.................... #byte B2SIDH = getenv("SFR:B2SIDH")    //0xE41 
.................... #byte B3SIDH = getenv("SFR:B3SIDH")    //0xE51 
.................... #byte B4SIDH = getenv("SFR:B4SIDH")    //0xE61 
.................... #byte B5SIDH = getenv("SFR:B5SIDH")    //0xE71 
....................  
.................... #byte B0SIDL = getenv("SFR:B0SIDL")    //0xE22 
.................... #byte B1SIDL = getenv("SFR:B1SIDL")    //0xE32 
.................... #byte B2SIDL = getenv("SFR:B2SIDL")    //0xE42 
.................... #byte B3SIDL = getenv("SFR:B3SIDL")    //0xE52 
.................... #byte B4SIDL = getenv("SFR:B4SIDL")    //0xE62 
.................... #byte B5SIDL = getenv("SFR:B5SIDL")    //0xE72 
....................  
.................... // extended identifier bytes 
.................... #byte B0EIDH = getenv("SFR:B0EIDH")    //0xE23 
.................... #byte B1EIDH = getenv("SFR:B1EIDH")    //0xE33 
.................... #byte B2EIDH = getenv("SFR:B2EIDH")    //0xE43 
.................... #byte B3EIDH = getenv("SFR:B3EIDH")    //0xE53 
.................... #byte B4EIDH = getenv("SFR:B4EIDH")    //0xE63 
.................... #byte B5EIDH = getenv("SFR:B5EIDH")    //0xE73 
....................  
.................... #byte B0EIDL = getenv("SFR:B0EIDL")    //0xE24 
.................... #byte B1EIDL = getenv("SFR:B1EIDL")    //0xE34 
.................... #byte B2EIDL = getenv("SFR:B2EIDL")    //0xE44 
.................... #byte B3EIDL = getenv("SFR:B3EIDL")    //0xE54 
.................... #byte B4EIDL = getenv("SFR:B4EIDL")    //0xE64 
.................... #byte B5EIDL = getenv("SFR:B5EIDL")    //0xE74 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////////////// Mask Select Registers //////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_MASK_FILTER_ASSOCIATE{ACCEPTANCE_MASK_0=0x00,ACCEPTANCE_MASK_1=0x01, 
....................                                FILTER_15=0x02,NO_MASK=0x03}; 
....................  
.................... //msel0 
.................... struct { 
....................    int fil0:2;   //0:1 filter zero select bits 
....................    int fil1:2;   //2:3 filter one select bits 
....................    int fil2:2;   //4:5 filter two select bits 
....................    int fil3:2;   //6:7 filter three select bits 
.................... } MSEL0; 
....................  
.................... //msel1 
.................... struct { 
....................    int fil4:2;   //0:1 filter four select bits 
....................    int fil5:2;   //2:3 filter five select bits 
....................    int fil6:2;   //4:5 filter six select bits 
....................    int fil7:2;   //6:7 filter seven select bits 
.................... } MSEL1; 
....................  
.................... //msel2 
.................... struct { 
....................    int fil8:2;   //0:1 filter eight select bits 
....................    int fil9:2;   //2:3 filter nine select bits 
....................    int fil10:2;  //4:5 filter ten select bits 
....................    int fil11:2;  //6:7 filter eleven select bits 
.................... } MSEL2; 
....................  
.................... //msel3 
.................... struct { 
....................    int fil12:2;   //0:1 filter twelve select bits 
....................    int fil13:2;   //2:3 filter thirteen select bits 
....................    int fil14:2;   //4:5 filter fourteen select bits 
....................    int fil15:2;   //6:7 filter fifteen select bits 
.................... } MSEL3; 
....................  
.................... #byte MSEL0 = getenv("SFR:MSEL0")      //0xDF0 
.................... #byte MSEL1 = getenv("SFR:MSEL1")      //0xDF1 
.................... #byte MSEL2 = getenv("SFR:MSEL2")      //0xDF2 
.................... #byte MSEL3 = getenv("SFR:MSEL3")      //0xDF3 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////// Transmit interrupts enable register //////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //txbie 
.................... struct { 
....................    int  void01:2; //0:1 
....................    int1 txb0ie;   //2  transmit buffer 0 interrupt enable bit 
....................    int1 txb1ie;   //3  transmit buffer 1 interrupt enable bit 
....................    int1 txb2ie;   //4  transmit buffer 2 interrupt enable bit 
....................    int  void567;  //5:7 
.................... } txbie; 
....................  
.................... #byte txbie = getenv("SFR:TXBIE")      //0xDFC 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////// Buffer interrupt enable register ////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //bie0 
.................... struct { 
....................    int1 rxb0ie;    //0 dedicated receive buffer 0 interrupt enable bit 
....................    int1 rxb1ie;    //1 dedicated receive buffer 1 interrupt enable bit 
....................    int1 b0ie;      //2 programmable transmit/receive buffer 0 interrupt enable bit 
....................    int1 b1ie;      //3 programmable transmit/receive buffer 1 interrupt enable bit 
....................    int1 b2ie;      //4 programmable transmit/receive buffer 2 interrupt enable bit 
....................    int1 b3ie;      //5 programmable transmit/receive buffer 3 interrupt enable bit 
....................    int1 b4ie;      //6 programmable transmit/receive buffer 4 interrupt enable bit 
....................    int1 b5ie;      //7 programmable transmit/receive buffer 5 interrupt enable bit 
.................... } bie0; 
....................  
.................... #byte bie0 = getenv("SFR:BIE0")     //0xDFA 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_FILTER_CONTROL{RXF0EN=0x0001, RXF1EN=0x0002, RXF2EN=0x0004, RXF3EN=0x0008, 
....................                         RXF4EN=0x0010, RXF5EN=0x0020, RXF6EN=0x0040, RXF7EN=0x0080, 
....................                         RXF8EN=0x0100, RXF9EN=0x0200,RXF10EN=0x0400,RXF11EN=0x0800, 
....................                        RXF12EN=0x1000,RXF13EN=0x2000,RXF14EN=0x4000,RXF15EN=0x8000}; 
....................  
.................... //receive filter control registers 
.................... #byte RXFCON0 = getenv("SFR:RXFCON0")     //0xDD4 
.................... #byte RXFCON1 = getenv("SFR:RXFCON1")     //0xDD5 
....................  
.................... //standard data bytes filter length count register 
.................... #byte SDFLC = getenv("SFR:SDFLC")      //0xDD8 
....................  
.................... // enumerated buffers and filters 
.................... enum CAN_FILTER_ASSOCIATION{F0BP=0x00 ,F1BP=0x01 ,F2BP=0x02 ,F3BP=0x03 ,F4BP=0x04, 
....................                             F5BP=0x05 ,F6BP=0x06 ,F7BP=0x07 ,F8BP=0x08 ,F9BP=0x09, 
....................                               F10BP=0x0A,F11BP=0x0B,F12BP=0x0C,F13BP=0x0D,F14BP=0x0E, 
....................                             F15BP=0x0F}; 
....................  
.................... enum CAN_FILTER_ASSOCIATION_BUFFERS { ARXB0=0x00, ARXB1=0x01, AB0=0x02, AB1=0x03, AB2=0x04, AB3=0x05, 
....................                AB4=0x06, AB5=0x07 }; 
....................  
.................... //receive filter buffer control registers 
.................... #byte RXFBCON0 = getenv("SFR:RXFBCON0")      //0xDE0 
.................... #byte RXFBCON1 = getenv("SFR:RXFBCON1")      //0xDE1 
.................... #byte RXFBCON2 = getenv("SFR:RXFBCON2")      //0xDE2 
.................... #byte RXFBCON3 = getenv("SFR:RXFBCON3")      //0xDE3 
.................... #byte RXFBCON4 = getenv("SFR:RXFBCON4")      //0xDE4 
.................... #byte RXFBCON5 = getenv("SFR:RXFBCON5")      //0xDE5 
.................... #byte RXFBCON6 = getenv("SFR:RXFBCON6")      //0xDE6 
.................... #byte RXFBCON7 = getenv("SFR:RXFBCON7")      //0xDE7 
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL = 0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;      //extendid id 
....................    int1 srr;      //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL = 0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0;    //4   //reserved 
....................    int1 rb1;    //5   //reserved 
....................    int1 rtr;    //6   //receiver remote transmission request bit 
....................    int1 void7;  //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
....................  
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0 = 0xF66 
.................... #byte TXRXBaD7 = 0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard identifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... #byte RXF6SIDH = getenv("SFR:RXF6SIDH")      //0xD60 
.................... #byte RXF6SIDL = getenv("SFR:RXF6SIDL")      //0xD61 
.................... #byte RXF7SIDH = getenv("SFR:RXF7SIDH")      //0xD64 
.................... #byte RXF7SIDL = getenv("SFR:RXF7SIDL")      //0xD65 
.................... #byte RXF8SIDH = getenv("SFR:RXF8SIDH")      //0xD68 
.................... #byte RXF8SIDL = getenv("SFR:RXF8SIDL")      //0xD69 
.................... #byte RXF9SIDH = getenv("SFR:RXF9SIDH")      //0xD70 
.................... #byte RXF9SIDL = getenv("SFR:RXF9SIDL")      //0xD71 
.................... #byte RXF10SIDH = getenv("SFR:RXF10SIDH")    //0xD74 
.................... #byte RXF10SIDL = getenv("SFR:RXF10SIDL")    //0xD75 
.................... #byte RXF11SIDH = getenv("SFR:RXF11SIDH")    //0xD78 
.................... #byte RXF11SIDL = getenv("SFR:RXF11SIDL")    //0xD79 
.................... #byte RXF12SIDH = getenv("SFR:RXF12SIDH")    //0xD80 
.................... #byte RXF12SIDL = getenv("SFR:RXF12SIDL")    //0xD81 
.................... #byte RXF13SIDH = getenv("SFR:RXF13SIDH")    //0xD84 
.................... #byte RXF13SIDL = getenv("SFR:RXF13SIDL")    //0xD85 
.................... #byte RXF14SIDH = getenv("SFR:RXF14SIDH")    //0xD88 
.................... #byte RXF14SIDL = getenv("SFR:RXF14SIDL")    //0xD89 
.................... #byte RXF15SIDH = getenv("SFR:RXF15SIDH")    //0xD90 
.................... #byte RXF15SIDL = getenv("SFR:RXF15SIDL")    //0xD91 
....................  
.................... //receive acceptance filter n extended identifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... #byte RXF6EIDH = getenv("SFR:RXF6EIDH")      //0xD62 
.................... #byte RXF6EIDL = getenv("SFR:RXF6EIDL")      //0xD63 
.................... #byte RXF7EIDH = getenv("SFR:RXF7EIDH")      //0xD66 
.................... #byte RXF7EIDL = getenv("SFR:RXF7EIDL")      //0xD67 
.................... #byte RXF8EIDH = getenv("SFR:RXF8EIDH")      //0xD6A 
.................... #byte RXF8EIDL = getenv("SFR:RXF8EIDL")      //0xD6B 
.................... #byte RXF9EIDH = getenv("SFR:RXF9EIDH")      //0xD72 
.................... #byte RXF9EIDL = getenv("SFR:RXF9EIDL")      //0xD73 
.................... #byte RXF10EIDH = getenv("SFR:RXF10EIDH")    //0xD76 
.................... #byte RXF10EIDL = getenv("SFR:RXF10EIDL")    //0xD77 
.................... #byte RXF11EIDH = getenv("SFR:RXF11EIDH")    //0xD7A 
.................... #byte RXF11EIDL = getenv("SFR:RXF11EIDL")    //0xD7B 
.................... #byte RXF12EIDH = getenv("SFR:RXF12EIDH")    //0xD82 
.................... #byte RXF12EIDL = getenv("SFR:RXF12EIDL")    //0xD83 
.................... #byte RXF13EIDH = getenv("SFR:RXF13EIDH")    //0xD86 
.................... #byte RXF13EIDL = getenv("SFR:RXF13EIDL")    //0xD87 
.................... #byte RXF14EIDH = getenv("SFR:RXF14EIDH")    //0xD8A 
.................... #byte RXF14EIDL = getenv("SFR:RXF14EIDL")    //0xD8B 
.................... #byte RXF15EIDH = getenv("SFR:RXF15EIDH")    //0xD92 
.................... #byte RXF15EIDL = getenv("SFR:RXF15EIDL")    //0xD93 
....................  
.................... // simple filter names 
.................... #define RXFILTER0 getenv("SFR:RXF0EIDL")     //0xF03 
.................... #define RXFILTER1 getenv("SFR:RXF1EIDL")     //0xF07 
.................... #define RXFILTER2 getenv("SFR:RXF2EIDL")     //0xF0B 
.................... #define RXFILTER3 getenv("SFR:RXF3EIDL")     //0xF0F 
.................... #define RXFILTER4 getenv("SFR:RXF4EIDL")     //0xF13 
.................... #define RXFILTER5 getenv("SFR:RXF5EIDL")     //0xF17 
.................... #define RXFILTER6 getenv("SFR:RXF6EIDL")     //0xD63 
.................... #define RXFILTER7 getenv("SFR:RXF7EIDL")     //0xD67 
.................... #define RXFILTER8 getenv("SFR:RXF8EIDL")     //0xD6B 
.................... #define RXFILTER9 getenv("SFR:RXF9EIDL")     //0xD73 
.................... #define RXFILTER10 getenv("SFR:RXF10EIDL")   //0xD77 
.................... #define RXFILTER11 getenv("SFR:RXF11EIDL")   //0xD7B 
.................... #define RXFILTER12 getenv("SFR:RXF12EIDL")   //0xD83 
.................... #define RXFILTER13 getenv("SFR:RXF13EIDL")   //0xD87 
.................... #define RXFILTER14 getenv("SFR:RXF14EIDL")   //0xD8B 
.................... #define RXFILTER15 getenv("SFR:RXF15EIDL")   //0xD93 
....................  
.................... //receive acceptance mask n standard identifier mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifier mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   //0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   //0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   //0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   //0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   //0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl;          // buffer overflow 
....................    unsigned int filthit;   // filter that allowed the frame into the buffer 
....................    unsigned int  buffer;   // receive buffer 
....................    int1 rtr;               // rtr requested 
....................    int1 ext;               // extended id 
....................    int1 inv;               // invalid id? 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_functional_mode(CAN_FUN_OP_MODE mode); 
.................... void  can_set_id(unsigned int *addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int *addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 &id, unsigned int *data, unsigned int &len, struct rx_stat &stat); 
.................... void  can_enable_rtr(PROG_BUFFER b); 
.................... void  can_disable_rtr(PROG_BUFFER b); 
.................... void  can_load_rtr(PROG_BUFFER b, unsigned int *data, unsigned int len); 
.................... void can_enable_filter(unsigned long filter); 
.................... void can_disable_filter(unsigned long filter); 
.................... void can_associate_filter_to_buffer(CAN_FILTER_ASSOCIATION_BUFFERS buffer, CAN_FILTER_ASSOCIATION filter); 
.................... void can_associate_filter_to_mask(CAN_MASK_FILTER_ASSOCIATE mask, CAN_FILTER_ASSOCIATION filter); 
.................... int1 can_fifo_getd(unsigned int32 &id, unsigned int *data, unsigned int &len, struct rx_stat &stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7) 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
.................... //macros 
.................... #define can_kbhit() (RXB0CON.rxful || RXB1CON.rxful || (B0CONR.rxful && !BSEL0.b0txen) || (B1CONR.rxful && !BSEL0.b1txen) || (B2CONR.rxful && !BSEL0.b2txen) || (B3CONR.rxful && !BSEL0.b3txen) || (B4CONR.rxful && !BSEL0.b4txen) || (B5CONR.rxful && !BSEL0.b5txen)) 
.................... #define can_tbe() (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq || (!B0CONT.txreq && BSEL0.b0txen) || (!B1CONT.txreq && BSEL0.b1txen) || (!B2CONT.txreq && BSEL0.b2txen) || (!B3CONT.txreq && BSEL0.b3txen) || (!B4CONT.txreq && BSEL0.b4txen) || (!B5CONT.txreq && BSEL0.b5txen)) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
.................... // current mode variable 
.................... // used by many of the device drivers to prevent damage from the mode 
.................... // 
.................... unsigned int curmode; 
.................... unsigned int curfunmode; 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
0806:  MOVLW  04
0808:  MOVWF  2F
080A:  RCALL  0688
....................    can_set_baud(); 
080C:  BRA    06AA
....................    curfunmode=CAN_FUN_OP_LEGACY; 
080E:  CLRF   06
....................  
....................    // RXB0CON 
....................    //    filthit0=0 
....................    //    jtoff=0 
....................    //      rxb0dben=1   buffer zero will overflow into buffer one 
....................    //      rxrtrro=0 
....................    //      rxm1:0=0      will receive all valid IDs 
....................    RXB0CON=0; 
0810:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
0812:  MOVLW  9F
0814:  ANDWF  F60,W
0816:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
0818:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
081A:  MOVFF  F60,F30
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
081E:  BCF    F70.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
0820:  BCF    F70.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added for PIC18F6585/8585/6680/8680 
0822:  BCF    F70.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added for PIC18F6585/8585/6680/8680 
0824:  BCF    F70.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
0826:  MOVLW  0E
0828:  MOVWF  4A
082A:  MOVLW  FB
082C:  MOVWF  49
082E:  CLRF   4E
0830:  CLRF   4D
0832:  CLRF   4C
0834:  CLRF   4B
0836:  MOVLW  01
0838:  MOVWF  4F
083A:  RCALL  06DE
....................    can_set_id(RXFILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
083C:  MOVLW  0E
083E:  MOVWF  4A
0840:  MOVLW  E3
0842:  MOVWF  49
0844:  CLRF   4E
0846:  CLRF   4D
0848:  CLRF   4C
084A:  CLRF   4B
084C:  MOVLW  01
084E:  MOVWF  4F
0850:  RCALL  06DE
....................    can_set_id(RXFILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
0852:  MOVLW  0E
0854:  MOVWF  4A
0856:  MOVLW  E7
0858:  MOVWF  49
085A:  CLRF   4E
085C:  CLRF   4D
085E:  CLRF   4C
0860:  CLRF   4B
0862:  MOVLW  01
0864:  MOVWF  4F
0866:  RCALL  06DE
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
0868:  MOVLW  0E
086A:  MOVWF  4A
086C:  SETF   49
086E:  CLRF   4E
0870:  CLRF   4D
0872:  CLRF   4C
0874:  CLRF   4B
0876:  MOVLW  01
0878:  MOVWF  4F
087A:  RCALL  06DE
....................    can_set_id(RXFILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
087C:  MOVLW  0E
087E:  MOVWF  4A
0880:  MOVLW  EB
0882:  MOVWF  49
0884:  CLRF   4E
0886:  CLRF   4D
0888:  CLRF   4C
088A:  CLRF   4B
088C:  MOVLW  01
088E:  MOVWF  4F
0890:  RCALL  06DE
....................    can_set_id(RXFILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
0892:  MOVLW  0E
0894:  MOVWF  4A
0896:  MOVLW  EF
0898:  MOVWF  49
089A:  CLRF   4E
089C:  CLRF   4D
089E:  CLRF   4C
08A0:  CLRF   4B
08A2:  MOVLW  01
08A4:  MOVWF  4F
08A6:  RCALL  06DE
....................    can_set_id(RXFILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
08A8:  MOVLW  0E
08AA:  MOVWF  4A
08AC:  MOVLW  F3
08AE:  MOVWF  49
08B0:  CLRF   4E
08B2:  CLRF   4D
08B4:  CLRF   4C
08B6:  CLRF   4B
08B8:  MOVLW  01
08BA:  MOVWF  4F
08BC:  RCALL  06DE
....................    can_set_id(RXFILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
08BE:  MOVLW  0E
08C0:  MOVWF  4A
08C2:  MOVLW  F7
08C4:  MOVWF  49
08C6:  CLRF   4E
08C8:  CLRF   4D
08CA:  CLRF   4C
08CC:  CLRF   4B
08CE:  MOVLW  01
08D0:  MOVWF  4F
08D2:  RCALL  06DE
....................  
....................    // set dynamic filters 
....................    can_set_id(RXFILTER6, 0, CAN_USE_EXTENDED_ID); 
08D4:  MOVLW  0E
08D6:  MOVWF  4A
08D8:  MOVLW  4B
08DA:  MOVWF  49
08DC:  CLRF   4E
08DE:  CLRF   4D
08E0:  CLRF   4C
08E2:  CLRF   4B
08E4:  MOVLW  01
08E6:  MOVWF  4F
08E8:  RCALL  06DE
....................    can_set_id(RXFILTER7, 0, CAN_USE_EXTENDED_ID); 
08EA:  MOVLW  0E
08EC:  MOVWF  4A
08EE:  MOVLW  4F
08F0:  MOVWF  49
08F2:  CLRF   4E
08F4:  CLRF   4D
08F6:  CLRF   4C
08F8:  CLRF   4B
08FA:  MOVLW  01
08FC:  MOVWF  4F
08FE:  RCALL  06DE
....................    can_set_id(RXFILTER8, 0, CAN_USE_EXTENDED_ID); 
0900:  MOVLW  0E
0902:  MOVWF  4A
0904:  MOVLW  53
0906:  MOVWF  49
0908:  CLRF   4E
090A:  CLRF   4D
090C:  CLRF   4C
090E:  CLRF   4B
0910:  MOVLW  01
0912:  MOVWF  4F
0914:  RCALL  06DE
....................    can_set_id(RXFILTER9, 0, CAN_USE_EXTENDED_ID); 
0916:  MOVLW  0E
0918:  MOVWF  4A
091A:  MOVLW  57
091C:  MOVWF  49
091E:  CLRF   4E
0920:  CLRF   4D
0922:  CLRF   4C
0924:  CLRF   4B
0926:  MOVLW  01
0928:  MOVWF  4F
092A:  RCALL  06DE
....................    can_set_id(RXFILTER10, 0, CAN_USE_EXTENDED_ID); 
092C:  MOVLW  0E
092E:  MOVWF  4A
0930:  MOVLW  5B
0932:  MOVWF  49
0934:  CLRF   4E
0936:  CLRF   4D
0938:  CLRF   4C
093A:  CLRF   4B
093C:  MOVLW  01
093E:  MOVWF  4F
0940:  RCALL  06DE
....................    can_set_id(RXFILTER11, 0, CAN_USE_EXTENDED_ID); 
0942:  MOVLW  0E
0944:  MOVWF  4A
0946:  MOVLW  5F
0948:  MOVWF  49
094A:  CLRF   4E
094C:  CLRF   4D
094E:  CLRF   4C
0950:  CLRF   4B
0952:  MOVLW  01
0954:  MOVWF  4F
0956:  RCALL  06DE
....................    can_set_id(RXFILTER12, 0, CAN_USE_EXTENDED_ID); 
0958:  MOVLW  0E
095A:  MOVWF  4A
095C:  MOVLW  63
095E:  MOVWF  49
0960:  CLRF   4E
0962:  CLRF   4D
0964:  CLRF   4C
0966:  CLRF   4B
0968:  MOVLW  01
096A:  MOVWF  4F
096C:  RCALL  06DE
....................    can_set_id(RXFILTER13, 0, CAN_USE_EXTENDED_ID); 
096E:  MOVLW  0E
0970:  MOVWF  4A
0972:  MOVLW  67
0974:  MOVWF  49
0976:  CLRF   4E
0978:  CLRF   4D
097A:  CLRF   4C
097C:  CLRF   4B
097E:  MOVLW  01
0980:  MOVWF  4F
0982:  RCALL  06DE
....................    can_set_id(RXFILTER14, 0, CAN_USE_EXTENDED_ID); 
0984:  MOVLW  0E
0986:  MOVWF  4A
0988:  MOVLW  6B
098A:  MOVWF  49
098C:  CLRF   4E
098E:  CLRF   4D
0990:  CLRF   4C
0992:  CLRF   4B
0994:  MOVLW  01
0996:  MOVWF  4F
0998:  RCALL  06DE
....................    can_set_id(RXFILTER15, 0, CAN_USE_EXTENDED_ID); 
099A:  MOVLW  0E
099C:  MOVWF  4A
099E:  MOVLW  6F
09A0:  MOVWF  49
09A2:  CLRF   4E
09A4:  CLRF   4D
09A6:  CLRF   4C
09A8:  CLRF   4B
09AA:  MOVLW  01
09AC:  MOVWF  4F
09AE:  RCALL  06DE
....................  
....................   #if (getenv("DEVICE") == "PIC18F6585") || (getenv("DEVICE") == "PIC18LF6585") || \ 
....................       (getenv("DEVICE") == "PIC18F6680") || (getenv("DEVICE") == "PIC18LF6680") || \ 
....................       (getenv("DEVICE") == "PIC18F8585") || (getenv("DEVICE") == "PIC18LF8585") || \ 
....................       (getenv("DEVICE") == "PIC18F8680") || (getenv("DEVICE") == "PIC18LF8680") 
....................    set_tris_g((*getenv("SFR:TRISG") & 0xFE) | 0x04);  //G2 in, G0 out 
....................    if(CAN_ENABLE_CANTX2) 
....................     bit_clear(*getenv("SFR:TRISG"), 1);  //G1 out 
....................   #elif getenv("FUSE_SET:CANE") 
....................    set_tris_e((*getenv("SFR:TRISE") & 0xDF) | 0x10);  //E4 in, E5 out 
....................   #elif getenv("FUSE_SET:CANC") 
....................    set_tris_c((*getenv("SFR:TRISC") & 0xBF) | 0x80);  //C7 in, C6 out 
....................   #else 
....................    set_tris_b((*getenv("SFR:TRISB") & 0xFB) | 0x08);  //B3 in, B2 out 
09B0:  MOVF   F93,W
09B2:  ANDLW  FB
09B4:  IORLW  08
09B6:  MOVWF  F93
....................   #endif 
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
09B8:  CLRF   2F
09BA:  RCALL  0688
09BC:  GOTO   268C (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //   BRGCON1 contains the prescaler bits and the Synchronization jump 
.................... //         width time bits. 
.................... // 
.................... //           the prescale values are 
.................... //              111111=(2*64)/clock=Tq 
.................... //              111110=(2*63)/clock=Tq 
.................... //                continued 
.................... //              000001=(2*2)/clock=Tq 
.................... //                000000=(2*1)/clock=Tq 
.................... // 
.................... //           in the case of can-18xxx8.h, the prescale bits are set to 
.................... //           000100=10/clock provided that the user does not define it 
.................... //           differently 
.................... // 
.................... //           The Synchronized Jump Width Bits are 
.................... //              11=4*Tq 
.................... //              10=3*Tq 
.................... //              01=2*Tq 
.................... //            00=1*Tq 
.................... // 
.................... //           in the case of can-18xxx8.h, the SJW bits are set to 0 or 1*Tq 
.................... // 
.................... //   BRGCON2 contains the Phase Segment 2 Time Select bit, the sample bit 
.................... //          the Phase Segment 1 bits, and the Propagation Time Select bits 
.................... // 
.................... //           SEG2PHTS 
.................... //                1=Freely Programmable 
.................... //              0=Maximum of PHEG1 or IPT, which ever is greatest 
.................... // 
.................... //           in the case of can-18xxx8.h, the SEG2PHTS bit is set to 1 for 
.................... //           freely programmable 
.................... // 
.................... //           SAM 
.................... //              1=Three Samples 
.................... //              0=One Sample 
.................... // 
.................... //           in the case of can-18xxx8.h, the SAM bit is set to 0 for 
.................... //           one sample 
.................... // 
.................... //           SEG1PH2:SEG1PH0 
.................... //              Phase Segment 1 = (SEG1PH2:SEG1PH0+1)*Tq 
.................... // 
.................... //           in the case of can-18xxx8.h, the SEG1PH2:SEG1PH0 bits are set to 5 
.................... //         for 6*Tq Phase Segment 1 Time 
.................... // 
.................... //           PRSEG2:PRSEG0 
.................... //              Propagation Time = (PRSEG2:PRSEG0+1)*TQ 
.................... // 
.................... //           in the case of can-18xxx8.h, the PRSEG2:PRSEG0 bits are set to 2 
.................... //           for 3*Tq Propagation Time 
.................... // 
.................... // BRGCON3 contains the WAKFIL bit and the Phase Segment 2 Time Select bits 
.................... // 
.................... //           WAKEFIL 
.................... //            1=CAN bus line filter is used for wake-up 
.................... //              0=CAN bus line filter is not used for wake-up 
.................... // 
.................... //           in the case of can-18xx8.h, the WAKEFIL bit is set to 0 for 
.................... //           CAN bus not used for wake-up 
.................... // 
.................... //           SEG2PH2:SEG2PH0 
.................... //              Phase Segment 2 Time = (SEG2PH2:SEG2PH0+1)*Tq 
.................... // 
.................... //           in the case of can-18xxx8.h, SEG2PH2:SEG3PH0 is set to 5 for 
.................... //         6*Tq Phase Segment 2 Time 
.................... // 
.................... // More information can be found in the PIC18F4580 datasheet section 23.9 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
06AA:  MOVLW  C0
06AC:  MOVLB  E
06AE:  ANDWF  x43,W
06B0:  IORLW  04
06B2:  MOVWF  x43
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
06B4:  MOVLW  3F
06B6:  ANDWF  x43,W
06B8:  MOVWF  x43
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
06BA:  MOVLW  F8
06BC:  ANDWF  x44,W
06BE:  IORLW  02
06C0:  MOVWF  x44
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
06C2:  MOVLW  C7
06C4:  ANDWF  x44,W
06C6:  IORLW  28
06C8:  MOVWF  x44
....................    BRGCON2.sam=CAN_BRG_SAM; 
06CA:  BCF    x44.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
06CC:  BSF    x44.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
06CE:  MOVLW  F8
06D0:  ANDWF  x45,W
06D2:  IORLW  05
06D4:  MOVWF  x45
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
06D6:  BCF    x45.6
06D8:  MOVLB  0
06DA:  GOTO   080E (RETURN)
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_mode 
.................... // 
.................... // This function first sets three most significant bits (reqop2:reqop0) 
.................... // to the mode given through the argument.  The modes can be 
.................... // 
.................... // mode 
.................... // 
.................... // 1xx  -> Configuration Mode 
.................... //             This mode allows the user to configure the Control Registers, 
.................... //            the Acceptance Mask Registers and the Acceptance Filter 
.................... //            Registers. 
.................... // 
.................... // 011  -> Listen Only Mode 
.................... //            This mode allows the PIC microcontroller to listen to the 
.................... //            bus but not actually write to it. 
.................... // 
.................... // 010  -> Loop Back Mode 
.................... //            This mode allows to the transmission of data directly from 
.................... //            the Transmission Buffers to the Receive Buffers without 
.................... //            actually driving any data to the bus 
.................... // 
.................... // 001  -> Disable Mode 
.................... //            This mode prevents the PIC microcontroller from transmitting 
.................... //            and receiving, however the WAKIF interrupt is still active 
.................... // 
.................... // 000  -> Normal Mode 
.................... //            This is the normal mode of operation for the CAN bus.  It 
.................... //            will receive all messages and is the only mode in which 
.................... //            data can be transmitted. 
.................... // 
.................... //   The reqop bits do not immediately change the mode of operation, the 
.................... // three most significant bits in the CANSTAT register (opmode2:opmode0) 
.................... // must change to reflect the actual change in mode, therefore a while 
.................... // statement is used to check if the CANSTAT opmode bits have changed to 
.................... // reflect the passed in mode 
.................... // 
.................... // More information can be found in the PIC18F4580 datasheet section 23.3 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
0688:  SWAPF  2F,W
068A:  ANDLW  70
068C:  MOVWF  00
068E:  BCF    FD8.0
0690:  RLCF   00,F
0692:  MOVLW  1F
0694:  ANDWF  F6F,W
0696:  IORWF  00,W
0698:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
069A:  MOVFF  F6E,00
069E:  SWAPF  00,F
06A0:  RRCF   00,W
06A2:  ANDLW  07
06A4:  SUBWF  2F,W
06A6:  BNZ   069A
06A8:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_functional_mode 
.................... // 
.................... // This function sets the functional mode of the PIC18F4580 ECAN module 
.................... // 
.................... //   mode 
.................... // 
.................... // 00    -> mode 0 or Legacy Mode.  The processor defaults to this mode 
.................... //            on reset in order to maintain backwards compatibility will 
.................... //            the previous PIC18Cxx8 and PIC18Fxx8 CAN modules.  All code 
.................... //            written for the listed microcontrollers will work on the 
.................... //            PIC18F4580 will no alterations. 
.................... // 
.................... //            This mode provides the exact same registers as the previous 
.................... //            modules.  These include 
.................... // 
.................... //            3 Transmit Buffers: TXB0, TXB1, TXB2 
.................... //            2 Receive Buffers: RXB0, RXB1 
.................... //            2 Acceptance Masks: RXM0, RXM1 
.................... //            6 Acceptance Filters: RXF0, RXF1, RXF2, RXF3, RXF4, RXF5 
.................... // 
.................... // 01  -> mode 1 or Enhanced Legacy Mode. This mode is the same as mode 
.................... //            0 with the exception that there are more resources available 
.................... //            to the CAN module.  These include 
.................... // 
.................... //            3  Transmit Buffers: TXB0, TXB1, TXB2 
.................... //            2  Receive Buffers: RXB0, RXB1 
.................... //            6  Programmable Buffers: B0, B1, B2, B3, B4, B5 
.................... //               Automatic RTR Handling on: B0, B1, B2, B3, B4, B5 
.................... //            16 Dynamically assigned acceptance filters: RXF0-RXF15 
.................... //            2  Dedicated mask registers,RXM0: RXM1 
.................... //            1  Programmable mask register: RXF15 
.................... //               Programmable data filter on standard identifier messages: SDFLC 
.................... // 
.................... // 10    -> mode 2 or Enhanced FIFO Mode.  This mode produces a first in 
.................... //            first out (FIFO) CAN data buffer.  This buffer can be from 2 too 
.................... //            8 bytes in length depending on which B buffers are used as receive 
.................... //            buffers and which are used as transmit buffers.  The first transmit 
.................... //            buffer defines the size, therefore if B4 was the first transmit 
.................... //            buffer, RXB0, BXB1, B0, B1, B2, and B3 would form the FIFO buffer 
.................... //            for a size of 6 bytes.  If B0 through B5 are all set to receive data, 
.................... //            the size will be 8 bytes.  If B0 is set to transmit, the size will 
.................... //            be 2 bytes.  The available resources include 
.................... // 
.................... //            3  Transmit Buffers: TXB0, TXB1, TXB2 
.................... //            2  Receive Buffers: RXB0, RXB1 
.................... //            6  Programmable Buffers: B0, B1, B2, B3, B4, B5 
.................... //               Automatic RTR Handling on: B0, B1, B2, B3, B4, B5 
.................... //            16 Acceptance Filters: RXF0-RXF15 
.................... //            2  Dedicated Mask Registers: RXM0, RXM1 
.................... //            1  Programmable mask register: RXF15 
.................... //               Programmable data filter on standard identifier messages: SDFLC 
.................... // 
.................... //   More information can be found in the PIC18F4580 datasheet section 23.4 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_set_functional_mode(CAN_FUN_OP_MODE mode) 
.................... { 
....................    curmode=CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
....................    ECANCON.mdsel=mode; 
....................    curfunmode=mode; 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... // 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int *addr, unsigned int32 id, int1 ext) { 
....................    //int *ptr; 
....................  
....................    //ptr=addr; 
....................  
....................    if (ext) {  //extended 
*
06DE:  MOVF   4F,F
06E0:  BZ    0786
....................       //eidl 
....................       *addr=make8(id,0); //0:7 
06E2:  MOVFF  49,FE9
06E6:  MOVFF  4A,FEA
06EA:  MOVFF  4B,FEF
....................  
....................       //eidh 
....................       addr--; 
06EE:  MOVF   49,W
06F0:  BTFSC  FD8.2
06F2:  DECF   4A,F
06F4:  DECF   49,F
....................       *addr=make8(id,1); //8:15 
06F6:  MOVFF  49,FE9
06FA:  MOVFF  4A,FEA
06FE:  MOVFF  4C,FEF
....................  
....................       //sidl 
....................       addr--; 
0702:  MOVF   49,W
0704:  BTFSC  FD8.2
0706:  DECF   4A,F
0708:  DECF   49,F
....................       *addr=make8(id,2) & 0x03;   //16:17 
070A:  MOVFF  49,FE9
070E:  MOVFF  4A,FEA
0712:  MOVF   4D,W
0714:  ANDLW  03
0716:  MOVWF  FEF
....................       *addr|=(make8(id,2) << 3) & 0xE0; //18:20 
0718:  MOVFF  49,FE9
071C:  MOVFF  4A,FEA
0720:  MOVFF  4D,00
0724:  RLCF   00,F
0726:  RLCF   00,F
0728:  RLCF   00,F
072A:  MOVLW  F8
072C:  ANDWF  00,F
072E:  MOVF   00,W
0730:  ANDLW  E0
0732:  IORWF  FEF,W
0734:  MOVWF  FEF
....................       *addr|=0x08; 
0736:  MOVFF  49,FE9
073A:  MOVFF  4A,FEA
073E:  MOVF   FEF,W
0740:  IORLW  08
0742:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       addr--; 
0744:  MOVF   49,W
0746:  BTFSC  FD8.2
0748:  DECF   4A,F
074A:  DECF   49,F
....................       *addr=((make8(id,2) >> 5) & 0x07 ); //21:23 
074C:  MOVFF  49,FE9
0750:  MOVFF  4A,FEA
0754:  MOVFF  4D,00
0758:  SWAPF  00,F
075A:  RRCF   00,F
075C:  MOVLW  07
075E:  ANDWF  00,F
0760:  MOVF   00,W
0762:  ANDLW  07
0764:  MOVWF  FEF
....................       *addr|=((make8(id,3) << 3) & 0xF8);//24:28 
0766:  MOVFF  49,FE9
076A:  MOVFF  4A,FEA
076E:  MOVFF  4E,00
0772:  RLCF   00,F
0774:  RLCF   00,F
0776:  RLCF   00,F
0778:  MOVLW  F8
077A:  ANDWF  00,F
077C:  MOVF   00,W
077E:  ANDLW  F8
0780:  IORWF  FEF,W
0782:  MOVWF  FEF
....................    } 
0784:  BRA    0804
....................    else {   //standard 
....................       //eidl 
....................       *addr=0; 
0786:  MOVFF  49,FE9
078A:  MOVFF  4A,FEA
078E:  CLRF   FEF
....................  
....................       //eidh 
....................       addr--; 
0790:  MOVF   49,W
0792:  BTFSC  FD8.2
0794:  DECF   4A,F
0796:  DECF   49,F
....................       *addr=0; 
0798:  MOVFF  49,FE9
079C:  MOVFF  4A,FEA
07A0:  CLRF   FEF
....................  
....................       //sidl 
....................       addr--; 
07A2:  MOVF   49,W
07A4:  BTFSC  FD8.2
07A6:  DECF   4A,F
07A8:  DECF   49,F
....................       *addr=(make8(id,0) << 5) & 0xE0; 
07AA:  MOVFF  49,FE9
07AE:  MOVFF  4A,FEA
07B2:  MOVFF  4B,00
07B6:  SWAPF  00,F
07B8:  RLCF   00,F
07BA:  MOVLW  E0
07BC:  ANDWF  00,F
07BE:  MOVF   00,W
07C0:  ANDLW  E0
07C2:  MOVWF  FEF
....................  
....................       //sidh 
....................       addr--; 
07C4:  MOVF   49,W
07C6:  BTFSC  FD8.2
07C8:  DECF   4A,F
07CA:  DECF   49,F
....................       *addr=(make8(id,0) >> 3) & 0x1F; 
07CC:  MOVFF  49,FE9
07D0:  MOVFF  4A,FEA
07D4:  MOVFF  4B,00
07D8:  RRCF   00,F
07DA:  RRCF   00,F
07DC:  RRCF   00,F
07DE:  MOVLW  1F
07E0:  ANDWF  00,F
07E2:  MOVF   00,W
07E4:  ANDLW  1F
07E6:  MOVWF  FEF
....................       *addr|=(make8(id,1) << 5) & 0xE0; 
07E8:  MOVFF  49,FE9
07EC:  MOVFF  4A,FEA
07F0:  MOVFF  4C,00
07F4:  SWAPF  00,F
07F6:  RLCF   00,F
07F8:  MOVLW  E0
07FA:  ANDWF  00,F
07FC:  MOVF   00,W
07FE:  ANDLW  E0
0800:  IORWF  FEF,W
0802:  MOVWF  FEF
....................    } 
0804:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_standard_id 
.................... // 
.................... // sets a standard id 
.................... // 
.................... // Parameters: 
.................... //      addr - the address that is to be set to the id 
.................... //      id - the actual id 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_set_standard_id(unsigned int *addr, unsigned int32 id) 
.................... { 
....................    //eidl 
....................    *addr=0; 
....................  
....................    //eidh 
....................    addr--; 
....................    *addr=0; 
....................  
....................    //sidl 
....................    addr--; 
....................    *addr=(make8(id,0) << 5) & 0xE0; 
....................  
....................    //sidh 
....................    addr--; 
....................    *addr=(make8(id,0) >> 3) & 0x1F; 
....................    *addr|=(make8(id,1) << 5) & 0xE0; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_extended_id 
.................... // 
.................... // sets an extended id 
.................... // 
.................... // Parameters: 
.................... //      addr - the address that is to be set to the id 
.................... //      id - the actual id 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_set_extended_id(unsigned int *addr, unsigned int32 id) 
.................... { 
....................    //eidl 
....................    *addr=make8(id,0); //0:7 
....................  
....................    //eidh 
....................    addr--; 
....................    *addr=make8(id,1); //8:15 
....................  
....................    //sidl 
....................    addr--; 
....................    *addr=make8(id,2) & 0x03;   //16:17 
....................    *addr|=(make8(id,2) << 3) & 0xE0; //18:20 
....................    *addr|=0x08; 
....................  
....................  
....................    //sidh 
....................    addr--; 
....................    *addr=((make8(id,2) >> 5) & 0x07 ); //21:23 
....................    *addr|=((make8(id,3) << 3) & 0xF8);//24:28 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int *addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int *ptr; 
....................  
....................    ret=0; 
*
18E2:  CLRF   4A
18E4:  CLRF   49
18E6:  CLRF   48
18E8:  CLRF   47
....................    ptr=addr; 
18EA:  MOVFF  45,4C
18EE:  MOVFF  44,4B
....................  
....................    if (ext) { 
18F2:  MOVF   46,F
18F4:  BTFSC  FD8.2
18F6:  BRA    1A0A
....................       ret=*ptr;  //eidl 
18F8:  MOVFF  4B,FE9
18FC:  MOVFF  4C,FEA
1900:  CLRF   4A
1902:  CLRF   49
1904:  CLRF   48
1906:  MOVFF  FEF,47
....................  
....................       ptr--;     //eidh 
190A:  MOVF   4B,W
190C:  BTFSC  FD8.2
190E:  DECF   4C,F
1910:  DECF   4B,F
....................       ret|=((unsigned int32)*ptr << 8); 
1912:  MOVFF  4B,FE9
1916:  MOVFF  4C,FEA
191A:  MOVF   FEF,W
191C:  CLRF   4F
191E:  CLRF   4E
1920:  MOVWF  4D
1922:  CLRF   00
1924:  MOVF   00,W
1926:  IORWF  47,F
1928:  MOVF   4D,W
192A:  IORWF  48,F
192C:  MOVF   4E,W
192E:  IORWF  49,F
1930:  MOVF   4F,W
1932:  IORWF  4A,F
....................  
....................       ptr--;     //sidl 
1934:  MOVF   4B,W
1936:  BTFSC  FD8.2
1938:  DECF   4C,F
193A:  DECF   4B,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
193C:  MOVFF  4B,FE9
1940:  MOVFF  4C,FEA
1944:  MOVF   FEF,W
1946:  CLRF   50
1948:  CLRF   4F
194A:  CLRF   4E
194C:  MOVWF  4D
194E:  MOVLW  03
1950:  ANDWF  4D,F
1952:  CLRF   4E
1954:  CLRF   4F
1956:  CLRF   50
1958:  CLRF   00
195A:  CLRF   01
195C:  MOVF   00,W
195E:  IORWF  47,F
1960:  MOVF   01,W
1962:  IORWF  48,F
1964:  MOVF   4D,W
1966:  IORWF  49,F
1968:  MOVF   4E,W
196A:  IORWF  4A,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
196C:  MOVFF  4B,FE9
1970:  MOVFF  4C,FEA
1974:  MOVF   FEF,W
1976:  CLRF   50
1978:  CLRF   4F
197A:  CLRF   4E
197C:  MOVWF  4D
197E:  MOVLW  E0
1980:  ANDWF  4D,F
1982:  CLRF   4E
1984:  CLRF   4F
1986:  CLRF   50
1988:  CLRF   00
198A:  RLCF   4D,W
198C:  MOVWF  01
198E:  RLCF   4E,W
1990:  MOVWF  02
1992:  RLCF   4F,W
1994:  MOVWF  03
1996:  RLCF   01,F
1998:  RLCF   02,F
199A:  RLCF   03,F
199C:  RLCF   01,F
199E:  RLCF   02,F
19A0:  RLCF   03,F
19A2:  RLCF   01,F
19A4:  RLCF   02,F
19A6:  RLCF   03,F
19A8:  RLCF   01,F
19AA:  RLCF   02,F
19AC:  RLCF   03,F
19AE:  MOVLW  E0
19B0:  ANDWF  01,F
19B2:  MOVF   00,W
19B4:  IORWF  47,F
19B6:  MOVF   01,W
19B8:  IORWF  48,F
19BA:  MOVF   02,W
19BC:  IORWF  49,F
19BE:  MOVF   03,W
19C0:  IORWF  4A,F
....................  
....................       ptr--;     //sidh 
19C2:  MOVF   4B,W
19C4:  BTFSC  FD8.2
19C6:  DECF   4C,F
19C8:  DECF   4B,F
....................       ret|=((unsigned int32)*ptr << 21); 
19CA:  MOVFF  4B,FE9
19CE:  MOVFF  4C,FEA
19D2:  MOVF   FEF,W
19D4:  CLRF   4E
19D6:  MOVWF  4D
19D8:  CLRF   00
19DA:  CLRF   01
19DC:  RLCF   4D,W
19DE:  MOVWF  02
19E0:  RLCF   4E,W
19E2:  MOVWF  03
19E4:  RLCF   02,F
19E6:  RLCF   03,F
19E8:  RLCF   02,F
19EA:  RLCF   03,F
19EC:  RLCF   02,F
19EE:  RLCF   03,F
19F0:  RLCF   02,F
19F2:  RLCF   03,F
19F4:  MOVLW  E0
19F6:  ANDWF  02,F
19F8:  MOVF   00,W
19FA:  IORWF  47,F
19FC:  MOVF   01,W
19FE:  IORWF  48,F
1A00:  MOVF   02,W
1A02:  IORWF  49,F
1A04:  MOVF   03,W
1A06:  IORWF  4A,F
....................  
....................    } 
1A08:  BRA    1AB0
....................    else { 
....................       ptr-=2;    //sidl 
1A0A:  MOVLW  02
1A0C:  SUBWF  4B,F
1A0E:  MOVLW  00
1A10:  SUBWFB 4C,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
1A12:  MOVFF  4B,FE9
1A16:  MOVFF  4C,FEA
1A1A:  MOVF   FEF,W
1A1C:  CLRF   50
1A1E:  CLRF   4F
1A20:  CLRF   4E
1A22:  MOVWF  4D
1A24:  MOVLW  E0
1A26:  ANDWF  4D,F
1A28:  CLRF   4E
1A2A:  CLRF   4F
1A2C:  CLRF   50
1A2E:  RRCF   50,W
1A30:  MOVWF  4A
1A32:  RRCF   4F,W
1A34:  MOVWF  49
1A36:  RRCF   4E,W
1A38:  MOVWF  48
1A3A:  RRCF   4D,W
1A3C:  MOVWF  47
1A3E:  RRCF   4A,F
1A40:  RRCF   49,F
1A42:  RRCF   48,F
1A44:  RRCF   47,F
1A46:  RRCF   4A,F
1A48:  RRCF   49,F
1A4A:  RRCF   48,F
1A4C:  RRCF   47,F
1A4E:  RRCF   4A,F
1A50:  RRCF   49,F
1A52:  RRCF   48,F
1A54:  RRCF   47,F
1A56:  RRCF   4A,F
1A58:  RRCF   49,F
1A5A:  RRCF   48,F
1A5C:  RRCF   47,F
1A5E:  MOVLW  07
1A60:  ANDWF  4A,F
....................  
....................       ptr--;     //sidh 
1A62:  MOVF   4B,W
1A64:  BTFSC  FD8.2
1A66:  DECF   4C,F
1A68:  DECF   4B,F
....................       ret|=((unsigned int32)*ptr << 3); 
1A6A:  MOVFF  4B,FE9
1A6E:  MOVFF  4C,FEA
1A72:  MOVF   FEF,W
1A74:  CLRF   50
1A76:  CLRF   4F
1A78:  CLRF   4E
1A7A:  MOVWF  4D
1A7C:  RLCF   4D,W
1A7E:  MOVWF  00
1A80:  RLCF   4E,W
1A82:  MOVWF  01
1A84:  RLCF   4F,W
1A86:  MOVWF  02
1A88:  RLCF   50,W
1A8A:  MOVWF  03
1A8C:  RLCF   00,F
1A8E:  RLCF   01,F
1A90:  RLCF   02,F
1A92:  RLCF   03,F
1A94:  RLCF   00,F
1A96:  RLCF   01,F
1A98:  RLCF   02,F
1A9A:  RLCF   03,F
1A9C:  MOVLW  F8
1A9E:  ANDWF  00,F
1AA0:  MOVF   00,W
1AA2:  IORWF  47,F
1AA4:  MOVF   01,W
1AA6:  IORWF  48,F
1AA8:  MOVF   02,W
1AAA:  IORWF  49,F
1AAC:  MOVF   03,W
1AAE:  IORWF  4A,F
....................    } 
....................  
....................    return(ret); 
1AB0:  MOVFF  47,00
1AB4:  MOVFF  48,01
1AB8:  MOVFF  49,02
1ABC:  MOVFF  4A,03
1AC0:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_extended_id 
.................... // 
.................... // reads the extended identification of a buffer 
.................... // 
.................... // Parameters: 
.................... //      addr - the address that is to be read 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_extended_id(unsigned int *addr) 
.................... { 
....................    unsigned int32 ret; 
....................  
....................    ret=*addr;  //eidl 
....................  
....................    addr--;     //eidh 
....................    ret|=((unsigned int32)*addr << 8); 
....................  
....................    addr--;     //sidl 
....................    ret|=((unsigned int32)*addr & 0x03) << 16; 
....................    ret|=((unsigned int32)*addr & 0xE0) << 13; 
....................  
....................    addr--;     //sidh 
....................    ret|=((unsigned int32)*addr << 21); 
....................  
....................    return (ret); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_standard_id 
.................... // 
.................... // reads the standard identification of a buffer 
.................... // 
.................... // Parameters 
.................... //      addr - the address that is to be read 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_standard_id(unsigned int *addr) 
.................... { 
....................    unsigned int32 ret; 
....................  
....................    addr-=2;    //sidl 
....................    ret=((unsigned int32)*addr & 0xE0) >> 5; 
....................  
....................    addr--;     //sidh 
....................    ret|=((unsigned int32)*addr << 3); 
....................  
....................    return (ret); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Parameters: 
.................... //       id - ID to transmit data as 
.................... //          enumerated as - RXB0ID,RXB1ID,B0ID,B1ID,B2ID,B3ID,B4ID,B5ID 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int *txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
0C7A:  MOVLW  0F
0C7C:  MOVWF  47
0C7E:  MOVLW  66
0C80:  MOVWF  46
....................  
....................     // find empty transmitter 
....................     // map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) 
0C82:  MOVLB  F
0C84:  BTFSC  x20.3
0C86:  BRA    0CA2
....................    { 
....................       if(curfunmode==CAN_FUN_OP_LEGACY) 
0C88:  MOVF   06,F
0C8A:  BNZ   0C96
....................          CANCON.win=CAN_WIN_TX0; 
0C8C:  MOVLW  F1
0C8E:  ANDWF  F6F,W
0C90:  IORLW  08
0C92:  MOVWF  F6F
0C94:  BRA    0C9E
....................       else 
....................          ECANCON.ewin=TX0; 
0C96:  MOVLW  E0
0C98:  ANDWF  F72,W
0C9A:  IORLW  03
0C9C:  MOVWF  F72
....................       port=0; 
0C9E:  CLRF   48
....................    } 
0CA0:  BRA    0D70
....................    else if (!TXB1CON.txreq) 
0CA2:  BTFSC  x10.3
0CA4:  BRA    0CC2
....................    { 
....................       if(curfunmode==CAN_FUN_OP_LEGACY) 
0CA6:  MOVF   06,F
0CA8:  BNZ   0CB4
....................          CANCON.win=CAN_WIN_TX1; 
0CAA:  MOVLW  F1
0CAC:  ANDWF  F6F,W
0CAE:  IORLW  06
0CB0:  MOVWF  F6F
0CB2:  BRA    0CBC
....................       else 
....................          ECANCON.ewin=TX1; 
0CB4:  MOVLW  E0
0CB6:  ANDWF  F72,W
0CB8:  IORLW  04
0CBA:  MOVWF  F72
....................       port=1; 
0CBC:  MOVLW  01
0CBE:  MOVWF  48
....................    } 
0CC0:  BRA    0D70
....................    else if (!TXB2CON.txreq) 
0CC2:  BTFSC  x00.3
0CC4:  BRA    0CE2
....................    { 
....................       if(curfunmode==CAN_FUN_OP_LEGACY) 
0CC6:  MOVF   06,F
0CC8:  BNZ   0CD4
....................          CANCON.win=CAN_WIN_TX2; 
0CCA:  MOVLW  F1
0CCC:  ANDWF  F6F,W
0CCE:  IORLW  04
0CD0:  MOVWF  F6F
0CD2:  BRA    0CDC
....................       else 
....................          ECANCON.ewin=TX2; 
0CD4:  MOVLW  E0
0CD6:  ANDWF  F72,W
0CD8:  IORLW  05
0CDA:  MOVWF  F72
....................       port=2; 
0CDC:  MOVLW  02
0CDE:  MOVWF  48
....................    } 
0CE0:  BRA    0D70
....................    else if (!B0CONT.txreq && BSEL0.b0txen) 
0CE2:  MOVLB  E
0CE4:  BTFSC  x80.3
0CE6:  BRA    0CFA
0CE8:  BTFSS  x7D.2
0CEA:  BRA    0CFA
....................    { 
....................       ECANCON.ewin=TXRX0; 
0CEC:  MOVLW  E0
0CEE:  ANDWF  F72,W
0CF0:  IORLW  12
0CF2:  MOVWF  F72
....................       port=3; 
0CF4:  MOVLW  03
0CF6:  MOVWF  48
....................    } 
0CF8:  BRA    0D6E
....................    else if (!B1CONT.txreq && BSEL0.b1txen) 
0CFA:  BTFSC  x90.3
0CFC:  BRA    0D10
0CFE:  BTFSS  x7D.3
0D00:  BRA    0D10
....................    { 
....................       ECANCON.ewin=TXRX1; 
0D02:  MOVLW  E0
0D04:  ANDWF  F72,W
0D06:  IORLW  13
0D08:  MOVWF  F72
....................       port=4; 
0D0A:  MOVLW  04
0D0C:  MOVWF  48
....................    } 
0D0E:  BRA    0D6E
....................    else if (!B2CONT.txreq && BSEL0.b2txen) 
0D10:  BTFSC  xA0.3
0D12:  BRA    0D26
0D14:  BTFSS  x7D.4
0D16:  BRA    0D26
....................    { 
....................       ECANCON.ewin=TXRX2; 
0D18:  MOVLW  E0
0D1A:  ANDWF  F72,W
0D1C:  IORLW  14
0D1E:  MOVWF  F72
....................       port=5; 
0D20:  MOVLW  05
0D22:  MOVWF  48
....................    } 
0D24:  BRA    0D6E
....................    else if (!B3CONT.txreq && BSEL0.b3txen) 
0D26:  BTFSC  xB0.3
0D28:  BRA    0D3C
0D2A:  BTFSS  x7D.5
0D2C:  BRA    0D3C
....................    { 
....................       ECANCON.ewin=TXRX3; 
0D2E:  MOVLW  E0
0D30:  ANDWF  F72,W
0D32:  IORLW  15
0D34:  MOVWF  F72
....................       port=6; 
0D36:  MOVLW  06
0D38:  MOVWF  48
....................    } 
0D3A:  BRA    0D6E
....................    else if (!B4CONT.txreq && BSEL0.b4txen) 
0D3C:  BTFSC  xC0.3
0D3E:  BRA    0D52
0D40:  BTFSS  x7D.6
0D42:  BRA    0D52
....................    { 
....................       ECANCON.ewin=TXRX4; 
0D44:  MOVLW  E0
0D46:  ANDWF  F72,W
0D48:  IORLW  16
0D4A:  MOVWF  F72
....................       port=7; 
0D4C:  MOVLW  07
0D4E:  MOVWF  48
....................    } 
0D50:  BRA    0D6E
....................    else if (!B5CONT.txreq && BSEL0.b5txen) 
0D52:  BTFSC  xD0.3
0D54:  BRA    0D68
0D56:  BTFSS  x7D.7
0D58:  BRA    0D68
....................    { 
....................       ECANCON.ewin=TXRX5; 
0D5A:  MOVLW  E0
0D5C:  ANDWF  F72,W
0D5E:  IORLW  17
0D60:  MOVWF  F72
....................       port=8; 
0D62:  MOVLW  08
0D64:  MOVWF  48
....................    } 
0D66:  BRA    0D6E
....................    else 
....................    { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
0D68:  MOVLW  00
0D6A:  MOVWF  01
0D6C:  BRA    0DF4
0D6E:  MOVLB  F
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
0D70:  MOVF   42,W
0D72:  ANDLW  03
0D74:  MOVWF  00
0D76:  MOVLW  FC
0D78:  ANDWF  F60,W
0D7A:  IORWF  00,W
0D7C:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
0D7E:  MOVLW  0F
0D80:  MOVWF  4A
0D82:  MOVLW  64
0D84:  MOVWF  49
0D86:  MOVFF  3E,4E
0D8A:  MOVFF  3D,4D
0D8E:  MOVFF  3C,4C
0D92:  MOVFF  3B,4B
0D96:  MOVFF  43,4F
0D9A:  MOVLB  0
0D9C:  RCALL  06DE
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
0D9E:  MOVFF  41,F65
....................    TXBaDLC.rtr=rtr; 
0DA2:  BCF    F65.6
0DA4:  BTFSC  44.0
0DA6:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
0DA8:  CLRF   45
0DAA:  MOVF   41,W
0DAC:  SUBWF  45,W
0DAE:  BC    0DD8
....................       *txd0=*data; 
0DB0:  MOVFF  3F,FE9
0DB4:  MOVFF  40,FEA
0DB8:  MOVFF  FEF,4B
0DBC:  MOVFF  47,FEA
0DC0:  MOVFF  46,FE9
0DC4:  MOVFF  4B,FEF
....................       txd0++; 
0DC8:  INCF   46,F
0DCA:  BTFSC  FD8.2
0DCC:  INCF   47,F
....................       data++; 
0DCE:  INCF   3F,F
0DD0:  BTFSC  FD8.2
0DD2:  INCF   40,F
0DD4:  INCF   45,F
0DD6:  BRA    0DAA
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
0DD8:  BSF    F60.3
....................  
....................    if(curfunmode==CAN_FUN_OP_LEGACY) 
0DDA:  MOVF   06,F
0DDC:  BNZ   0DE6
....................       CANCON.win=CAN_WIN_RX0; 
0DDE:  MOVLW  F1
0DE0:  ANDWF  F6F,W
0DE2:  MOVWF  F6F
0DE4:  BRA    0DEE
....................    else 
....................       ECANCON.ewin=RX0; 
0DE6:  MOVLW  E0
0DE8:  ANDWF  F72,W
0DEA:  IORLW  10
0DEC:  MOVWF  F72
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
0DEE:  MOVLW  01
0DF0:  MOVWF  01
0DF2:  MOVLB  E
0DF4:  MOVLB  0
0DF6:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Parameters: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             received it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 &id, unsigned int *data, unsigned int &len, struct rx_stat &stat) 
.................... { 
....................    unsigned int i; 
....................    unsigned int *ptr; 
....................  
....................    if (RXB0CON.rxful) 
*
1B80:  BTFSS  F60.7
1B82:  BRA    1BC2
*
2912:  BTFSS  F60.7
2914:  BRA    2954
....................    { 
....................       if(curfunmode==CAN_FUN_OP_LEGACY) 
*
1B84:  MOVF   06,F
1B86:  BNZ   1B90
*
2916:  MOVF   06,F
2918:  BNZ   2922
....................          CANCON.win=CAN_WIN_RX0; 
*
1B88:  MOVLW  F1
1B8A:  ANDWF  F6F,W
1B8C:  MOVWF  F6F
1B8E:  BRA    1B98
*
291A:  MOVLW  F1
291C:  ANDWF  F6F,W
291E:  MOVWF  F6F
2920:  BRA    292A
....................       else 
....................          ECANCON.ewin=RX0;          // this is if in functional mode 1 or 2 
*
1B90:  MOVLW  E0
1B92:  ANDWF  F72,W
1B94:  IORLW  10
1B96:  MOVWF  F72
*
2922:  MOVLW  E0
2924:  ANDWF  F72,W
2926:  IORLW  10
2928:  MOVWF  F72
....................  
....................       stat.buffer=0; 
*
1B98:  CLRF   0B
*
292A:  CLRF   0B
....................  
....................       //CAN_INT_RXB0IF=0;           // moved to end of function 
....................  
....................       if(curfunmode) 
*
1B9A:  MOVF   06,F
1B9C:  BZ    1BAE
*
292C:  MOVF   06,F
292E:  BZ    2940
....................       { 
....................          stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
*
1B9E:  BCF    09.0
1BA0:  BTFSC  F71.6
1BA2:  BSF    09.0
*
2930:  BCF    09.0
2932:  BTFSC  F71.6
2934:  BSF    09.0
....................          COMSTAT_MODE_1.rxnovfl = 0; 
*
1BA4:  BCF    F71.6
*
2936:  BCF    F71.6
....................          stat.filthit=RXB0CON_MODE_1.filthit; 
*
1BA6:  MOVF   F60,W
1BA8:  ANDLW  1F
1BAA:  MOVWF  0A
*
2938:  MOVF   F60,W
293A:  ANDLW  1F
293C:  MOVWF  0A
....................       } 
*
1BAC:  BRA    1BC0
*
293E:  BRA    2952
....................       else 
....................       { 
....................          stat.err_ovfl=COMSTAT.rx0ovfl; 
*
1BAE:  BCF    09.0
1BB0:  BTFSC  F71.7
1BB2:  BSF    09.0
*
2940:  BCF    09.0
2942:  BTFSC  F71.7
2944:  BSF    09.0
....................          COMSTAT.rx0ovfl=0; 
*
1BB4:  BCF    F71.7
*
2946:  BCF    F71.7
....................  
....................          if (RXB0CON.rxb0dben) 
*
1BB6:  BTFSS  F60.2
1BB8:  BRA    1BC0
*
2948:  BTFSS  F60.2
294A:  BRA    2952
....................          { 
....................             stat.filthit=RXB0CON.filthit0; 
*
1BBA:  CLRF   0A
1BBC:  BTFSC  F60.0
1BBE:  INCF   0A,F
*
294C:  CLRF   0A
294E:  BTFSC  F60.0
2950:  INCF   0A,F
....................          } 
....................       } 
....................    } 
*
1BC0:  BRA    1CE8
*
2952:  BRA    2A7A
....................    else if ( RXB1CON.rxful ) 
*
1BC2:  MOVLB  F
1BC4:  BTFSS  x30.7
1BC6:  BRA    1C06
*
2954:  MOVLB  F
2956:  BTFSS  x30.7
2958:  BRA    2998
....................    { 
....................       if(curfunmode==CAN_FUN_OP_LEGACY) 
*
1BC8:  MOVF   06,F
1BCA:  BNZ   1BD6
*
295A:  MOVF   06,F
295C:  BNZ   2968
....................          CANCON.win=CAN_WIN_RX1; 
*
1BCC:  MOVLW  F1
1BCE:  ANDWF  F6F,W
1BD0:  IORLW  0A
1BD2:  MOVWF  F6F
1BD4:  BRA    1BDE
*
295E:  MOVLW  F1
2960:  ANDWF  F6F,W
2962:  IORLW  0A
2964:  MOVWF  F6F
2966:  BRA    2970
....................       else 
....................          ECANCON.ewin=RX1; 
*
1BD6:  MOVLW  E0
1BD8:  ANDWF  F72,W
1BDA:  IORLW  11
1BDC:  MOVWF  F72
*
2968:  MOVLW  E0
296A:  ANDWF  F72,W
296C:  IORLW  11
296E:  MOVWF  F72
....................  
....................       stat.buffer=1; 
*
1BDE:  MOVLW  01
1BE0:  MOVWF  0B
*
2970:  MOVLW  01
2972:  MOVWF  0B
....................  
....................       //CAN_INT_RXB1IF=0;           //moved to end of function 
....................  
....................       if(curfunmode) 
*
1BE2:  MOVF   06,F
1BE4:  BZ    1BF6
*
2974:  MOVF   06,F
2976:  BZ    2988
....................       { 
....................          stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
*
1BE6:  BCF    09.0
1BE8:  BTFSC  F71.6
1BEA:  BSF    09.0
*
2978:  BCF    09.0
297A:  BTFSC  F71.6
297C:  BSF    09.0
....................          COMSTAT_MODE_1.rxnovfl = 0; 
*
1BEC:  BCF    F71.6
*
297E:  BCF    F71.6
....................          stat.filthit=RXB1CON_MODE_1.filthit; 
*
1BEE:  MOVF   x30,W
1BF0:  ANDLW  1F
1BF2:  MOVWF  0A
*
2980:  MOVF   x30,W
2982:  ANDLW  1F
2984:  MOVWF  0A
....................       } 
*
1BF4:  BRA    1C04
*
2986:  BRA    2996
....................       else 
....................       { 
....................          stat.err_ovfl=COMSTAT.rx1ovfl; 
*
1BF6:  BCF    09.0
1BF8:  BTFSC  F71.6
1BFA:  BSF    09.0
*
2988:  BCF    09.0
298A:  BTFSC  F71.6
298C:  BSF    09.0
....................          COMSTAT.rx1ovfl=0; 
*
1BFC:  BCF    F71.6
*
298E:  BCF    F71.6
....................  
....................          stat.filthit=RXB1CON.filthit; 
*
1BFE:  MOVF   x30,W
1C00:  ANDLW  07
1C02:  MOVWF  0A
*
2990:  MOVF   x30,W
2992:  ANDLW  07
2994:  MOVWF  0A
....................       } 
....................    } 
*
1C04:  BRA    1CE6
*
2996:  BRA    2A78
....................    else if (B0CONR.rxful && !BSEL0.b0txen) 
*
1C06:  MOVLB  E
1C08:  BTFSS  x80.7
1C0A:  BRA    1C2C
1C0C:  BTFSC  x7D.2
1C0E:  BRA    1C2C
*
2998:  MOVLB  E
299A:  BTFSS  x80.7
299C:  BRA    29BE
299E:  BTFSC  x7D.2
29A0:  BRA    29BE
....................    { 
....................       ECANCON.ewin=TXRX0; 
*
1C10:  MOVLW  E0
1C12:  ANDWF  F72,W
1C14:  IORLW  12
1C16:  MOVWF  F72
*
29A2:  MOVLW  E0
29A4:  ANDWF  F72,W
29A6:  IORLW  12
29A8:  MOVWF  F72
....................       stat.buffer=2; 
*
1C18:  MOVLW  02
1C1A:  MOVWF  0B
*
29AA:  MOVLW  02
29AC:  MOVWF  0B
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
*
1C1C:  BCF    09.0
1C1E:  BTFSC  F71.6
1C20:  BSF    09.0
*
29AE:  BCF    09.0
29B0:  BTFSC  F71.6
29B2:  BSF    09.0
....................       COMSTAT_MODE_1.rxnovfl = 0; 
*
1C22:  BCF    F71.6
*
29B4:  BCF    F71.6
....................       stat.filthit=B0CONR.filhit; 
*
1C24:  MOVF   x80,W
1C26:  ANDLW  1F
1C28:  MOVWF  0A
*
29B6:  MOVF   x80,W
29B8:  ANDLW  1F
29BA:  MOVWF  0A
....................  
....................      // B0CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
*
1C2A:  BRA    1CE6
*
29BC:  BRA    2A78
....................    else if (B1CONR.rxful && !BSEL0.b1txen) 
*
1C2C:  BTFSS  x90.7
1C2E:  BRA    1C50
1C30:  BTFSC  x7D.3
1C32:  BRA    1C50
*
29BE:  BTFSS  x90.7
29C0:  BRA    29E2
29C2:  BTFSC  x7D.3
29C4:  BRA    29E2
....................    { 
....................       ECANCON.ewin=TXRX1; 
*
1C34:  MOVLW  E0
1C36:  ANDWF  F72,W
1C38:  IORLW  13
1C3A:  MOVWF  F72
*
29C6:  MOVLW  E0
29C8:  ANDWF  F72,W
29CA:  IORLW  13
29CC:  MOVWF  F72
....................       stat.buffer=3; 
*
1C3C:  MOVLW  03
1C3E:  MOVWF  0B
*
29CE:  MOVLW  03
29D0:  MOVWF  0B
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
*
1C40:  BCF    09.0
1C42:  BTFSC  F71.6
1C44:  BSF    09.0
*
29D2:  BCF    09.0
29D4:  BTFSC  F71.6
29D6:  BSF    09.0
....................       COMSTAT_MODE_1.rxnovfl = 0; 
*
1C46:  BCF    F71.6
*
29D8:  BCF    F71.6
....................       stat.filthit=B1CONR.filhit; 
*
1C48:  MOVF   x90,W
1C4A:  ANDLW  1F
1C4C:  MOVWF  0A
*
29DA:  MOVF   x90,W
29DC:  ANDLW  1F
29DE:  MOVWF  0A
....................  
....................       //B1CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
*
1C4E:  BRA    1CE6
*
29E0:  BRA    2A78
....................    else if (B2CONR.rxful && !BSEL0.b2txen) 
*
1C50:  BTFSS  xA0.7
1C52:  BRA    1C74
1C54:  BTFSC  x7D.4
1C56:  BRA    1C74
*
29E2:  BTFSS  xA0.7
29E4:  BRA    2A06
29E6:  BTFSC  x7D.4
29E8:  BRA    2A06
....................    { 
....................       ECANCON.ewin=TXRX2; 
*
1C58:  MOVLW  E0
1C5A:  ANDWF  F72,W
1C5C:  IORLW  14
1C5E:  MOVWF  F72
*
29EA:  MOVLW  E0
29EC:  ANDWF  F72,W
29EE:  IORLW  14
29F0:  MOVWF  F72
....................       stat.buffer=4; 
*
1C60:  MOVLW  04
1C62:  MOVWF  0B
*
29F2:  MOVLW  04
29F4:  MOVWF  0B
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
*
1C64:  BCF    09.0
1C66:  BTFSC  F71.6
1C68:  BSF    09.0
*
29F6:  BCF    09.0
29F8:  BTFSC  F71.6
29FA:  BSF    09.0
....................       COMSTAT_MODE_1.rxnovfl = 0; 
*
1C6A:  BCF    F71.6
*
29FC:  BCF    F71.6
....................       stat.filthit=B2CONR.filhit; 
*
1C6C:  MOVF   xA0,W
1C6E:  ANDLW  1F
1C70:  MOVWF  0A
*
29FE:  MOVF   xA0,W
2A00:  ANDLW  1F
2A02:  MOVWF  0A
....................  
....................       //B2CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
*
1C72:  BRA    1CE6
*
2A04:  BRA    2A78
....................    else if (B3CONR.rxful && !BSEL0.b3txen) 
*
1C74:  BTFSS  xB0.7
1C76:  BRA    1C98
1C78:  BTFSC  x7D.5
1C7A:  BRA    1C98
*
2A06:  BTFSS  xB0.7
2A08:  BRA    2A2A
2A0A:  BTFSC  x7D.5
2A0C:  BRA    2A2A
....................    { 
....................       ECANCON.ewin=TXRX3; 
*
1C7C:  MOVLW  E0
1C7E:  ANDWF  F72,W
1C80:  IORLW  15
1C82:  MOVWF  F72
*
2A0E:  MOVLW  E0
2A10:  ANDWF  F72,W
2A12:  IORLW  15
2A14:  MOVWF  F72
....................       stat.buffer=5; 
*
1C84:  MOVLW  05
1C86:  MOVWF  0B
*
2A16:  MOVLW  05
2A18:  MOVWF  0B
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
*
1C88:  BCF    09.0
1C8A:  BTFSC  F71.6
1C8C:  BSF    09.0
*
2A1A:  BCF    09.0
2A1C:  BTFSC  F71.6
2A1E:  BSF    09.0
....................       COMSTAT_MODE_1.rxnovfl = 0; 
*
1C8E:  BCF    F71.6
*
2A20:  BCF    F71.6
....................       stat.filthit=B3CONR.filhit; 
*
1C90:  MOVF   xB0,W
1C92:  ANDLW  1F
1C94:  MOVWF  0A
*
2A22:  MOVF   xB0,W
2A24:  ANDLW  1F
2A26:  MOVWF  0A
....................  
....................       //B3CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
*
1C96:  BRA    1CE6
*
2A28:  BRA    2A78
....................    else if (B4CONR.rxful && !BSEL0.b4txen) 
*
1C98:  BTFSS  xC0.7
1C9A:  BRA    1CBC
1C9C:  BTFSC  x7D.6
1C9E:  BRA    1CBC
*
2A2A:  BTFSS  xC0.7
2A2C:  BRA    2A4E
2A2E:  BTFSC  x7D.6
2A30:  BRA    2A4E
....................    { 
....................       ECANCON.ewin=TXRX4; 
*
1CA0:  MOVLW  E0
1CA2:  ANDWF  F72,W
1CA4:  IORLW  16
1CA6:  MOVWF  F72
*
2A32:  MOVLW  E0
2A34:  ANDWF  F72,W
2A36:  IORLW  16
2A38:  MOVWF  F72
....................       stat.buffer=6; 
*
1CA8:  MOVLW  06
1CAA:  MOVWF  0B
*
2A3A:  MOVLW  06
2A3C:  MOVWF  0B
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
*
1CAC:  BCF    09.0
1CAE:  BTFSC  F71.6
1CB0:  BSF    09.0
*
2A3E:  BCF    09.0
2A40:  BTFSC  F71.6
2A42:  BSF    09.0
....................       COMSTAT_MODE_1.rxnovfl = 0; 
*
1CB2:  BCF    F71.6
*
2A44:  BCF    F71.6
....................       stat.filthit=B4CONR.filhit; 
*
1CB4:  MOVF   xC0,W
1CB6:  ANDLW  1F
1CB8:  MOVWF  0A
*
2A46:  MOVF   xC0,W
2A48:  ANDLW  1F
2A4A:  MOVWF  0A
....................  
....................       //B4CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
*
1CBA:  BRA    1CE6
*
2A4C:  BRA    2A78
....................    else if (B5CONR.rxful && !BSEL0.b5txen) 
*
1CBC:  BTFSS  xD0.7
1CBE:  BRA    1CE0
1CC0:  BTFSC  x7D.7
1CC2:  BRA    1CE0
*
2A4E:  BTFSS  xD0.7
2A50:  BRA    2A72
2A52:  BTFSC  x7D.7
2A54:  BRA    2A72
....................    { 
....................       ECANCON.ewin=TXRX5; 
*
1CC4:  MOVLW  E0
1CC6:  ANDWF  F72,W
1CC8:  IORLW  17
1CCA:  MOVWF  F72
*
2A56:  MOVLW  E0
2A58:  ANDWF  F72,W
2A5A:  IORLW  17
2A5C:  MOVWF  F72
....................       stat.buffer=7; 
*
1CCC:  MOVLW  07
1CCE:  MOVWF  0B
*
2A5E:  MOVLW  07
2A60:  MOVWF  0B
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
*
1CD0:  BCF    09.0
1CD2:  BTFSC  F71.6
1CD4:  BSF    09.0
*
2A62:  BCF    09.0
2A64:  BTFSC  F71.6
2A66:  BSF    09.0
....................       COMSTAT_MODE_1.rxnovfl = 0; 
*
1CD6:  BCF    F71.6
*
2A68:  BCF    F71.6
....................       stat.filthit=B5CONR.filhit; 
*
1CD8:  MOVF   xD0,W
1CDA:  ANDLW  1F
1CDC:  MOVWF  0A
*
2A6A:  MOVF   xD0,W
2A6C:  ANDLW  1F
2A6E:  MOVWF  0A
....................  
....................       //B5CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
*
1CDE:  BRA    1CE6
*
2A70:  BRA    2A78
....................    else 
....................    { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
*
1CE0:  MOVLW  00
1CE2:  MOVWF  01
1CE4:  BRA    1DEE
1CE6:  MOVLB  0
*
2A72:  MOVLW  00
2A74:  MOVWF  01
2A76:  BRA    2B82
2A78:  MOVLB  0
....................    } 
....................  
....................    len = RXBaDLC.dlc; 
*
1CE8:  MOVF   F65,W
1CEA:  ANDLW  0F
1CEC:  MOVWF  15
*
2A7A:  MOVF   F65,W
2A7C:  ANDLW  0F
2A7E:  MOVWF  15
....................    stat.rtr=RXBaDLC.rtr; 
*
1CEE:  BCF    0C.0
1CF0:  BTFSC  F65.6
1CF2:  BSF    0C.0
*
2A80:  BCF    0C.0
2A82:  BTFSC  F65.6
2A84:  BSF    0C.0
....................  
....................    stat.ext=TXRXBaSIDL.ext; 
*
1CF4:  BCF    0C.1
1CF6:  BTFSC  F62.3
1CF8:  BSF    0C.1
*
2A86:  BCF    0C.1
2A88:  BTFSC  F62.3
2A8A:  BSF    0C.1
....................    id=can_get_id(TXRXBaID,stat.ext); 
*
1CFA:  MOVLW  00
1CFC:  BTFSC  0C.1
1CFE:  MOVLW  01
1D00:  MOVWF  3A
1D02:  MOVLW  0F
1D04:  MOVWF  45
1D06:  MOVLW  64
1D08:  MOVWF  44
1D0A:  MOVFF  3A,46
1D0E:  RCALL  18E2
1D10:  MOVFF  03,10
1D14:  MOVFF  02,0F
1D18:  MOVFF  01,0E
1D1C:  MOVFF  00,0D
*
2A8C:  MOVLW  00
2A8E:  BTFSC  0C.1
2A90:  MOVLW  01
2A92:  MOVWF  3A
2A94:  MOVLW  0F
2A96:  MOVWF  45
2A98:  MOVLW  64
2A9A:  MOVWF  44
2A9C:  MOVFF  3A,46
2AA0:  CALL   18E2
2AA4:  MOVFF  03,10
2AA8:  MOVFF  02,0F
2AAC:  MOVFF  01,0E
2AB0:  MOVFF  00,0D
....................  
....................    ptr = &TXRXBaD0; 
*
1D20:  MOVLW  0F
1D22:  MOVWF  39
1D24:  MOVLW  66
1D26:  MOVWF  38
*
2AB4:  MOVLW  0F
2AB6:  MOVWF  39
2AB8:  MOVLW  66
2ABA:  MOVWF  38
....................    for ( i = 0; i < len; i++ ) 
*
1D28:  CLRF   37
1D2A:  MOVF   15,W
1D2C:  SUBWF  37,W
1D2E:  BC    1D58
*
2ABC:  CLRF   37
2ABE:  MOVF   15,W
2AC0:  SUBWF  37,W
2AC2:  BC    2AEC
....................    { 
....................       *data = *ptr; 
*
1D30:  MOVFF  38,FE9
1D34:  MOVFF  39,FEA
1D38:  MOVFF  FEF,3C
1D3C:  MOVFF  36,FEA
1D40:  MOVFF  35,FE9
1D44:  MOVFF  3C,FEF
*
2AC4:  MOVFF  38,FE9
2AC8:  MOVFF  39,FEA
2ACC:  MOVFF  FEF,3C
2AD0:  MOVFF  36,FEA
2AD4:  MOVFF  35,FE9
2AD8:  MOVFF  3C,FEF
....................       data++; 
*
1D48:  INCF   35,F
1D4A:  BTFSC  FD8.2
1D4C:  INCF   36,F
*
2ADC:  INCF   35,F
2ADE:  BTFSC  FD8.2
2AE0:  INCF   36,F
....................       ptr++; 
*
1D4E:  INCF   38,F
1D50:  BTFSC  FD8.2
1D52:  INCF   39,F
1D54:  INCF   37,F
1D56:  BRA    1D2A
*
2AE2:  INCF   38,F
2AE4:  BTFSC  FD8.2
2AE6:  INCF   39,F
2AE8:  INCF   37,F
2AEA:  BRA    2ABE
....................    } 
....................  
....................    switch(stat.buffer)     //switch statement to clear rxful flag and interrupt flag 
*
1D58:  MOVF   0B,W
1D5A:  BZ    1D7A
1D5C:  XORLW  01
1D5E:  BZ    1D88
1D60:  XORLW  03
1D62:  BZ    1D92
1D64:  XORLW  01
1D66:  BZ    1D9C
1D68:  XORLW  07
1D6A:  BZ    1DA6
1D6C:  XORLW  01
1D6E:  BZ    1DB0
1D70:  XORLW  03
1D72:  BZ    1DBA
1D74:  XORLW  01
1D76:  BZ    1DC4
1D78:  BRA    1DCC
*
2AEC:  MOVF   0B,W
2AEE:  BZ    2B0E
2AF0:  XORLW  01
2AF2:  BZ    2B1C
2AF4:  XORLW  03
2AF6:  BZ    2B26
2AF8:  XORLW  01
2AFA:  BZ    2B30
2AFC:  XORLW  07
2AFE:  BZ    2B3A
2B00:  XORLW  01
2B02:  BZ    2B44
2B04:  XORLW  03
2B06:  BZ    2B4E
2B08:  XORLW  01
2B0A:  BZ    2B58
2B0C:  BRA    2B60
....................    { 
....................       case 0: 
....................          RXB0CON.rxful=0; 
*
1D7A:  BCF    F60.7
*
2B0E:  BCF    F60.7
....................          if(curfunmode) 
*
1D7C:  MOVF   06,F
1D7E:  BZ    1D84
*
2B10:  MOVF   06,F
2B12:  BZ    2B18
....................             CAN_INT_RXB1IF=0; 
*
1D80:  BCF    F77.1
1D82:  BRA    1D86
*
2B14:  BCF    F77.1
2B16:  BRA    2B1A
....................          else 
....................             CAN_INT_RXB0IF=0; 
*
1D84:  BCF    F77.0
*
2B18:  BCF    F77.0
....................          break; 
*
1D86:  BRA    1DCC
*
2B1A:  BRA    2B60
....................       case 1: 
....................          RXB1CON.rxful=0; 
*
1D88:  MOVLB  F
1D8A:  BCF    x30.7
*
2B1C:  MOVLB  F
2B1E:  BCF    x30.7
....................          CAN_INT_RXB1IF=0; 
*
1D8C:  BCF    F77.1
*
2B20:  BCF    F77.1
....................          break; 
*
1D8E:  MOVLB  0
1D90:  BRA    1DCC
*
2B22:  MOVLB  0
2B24:  BRA    2B60
....................       case 2: 
....................          B0CONR.rxful=0; 
*
1D92:  MOVLB  E
1D94:  BCF    x80.7
*
2B26:  MOVLB  E
2B28:  BCF    x80.7
....................          CAN_INT_RXB1IF=0; 
*
1D96:  BCF    F77.1
*
2B2A:  BCF    F77.1
....................          break; 
*
1D98:  MOVLB  0
1D9A:  BRA    1DCC
*
2B2C:  MOVLB  0
2B2E:  BRA    2B60
....................       case 3: 
....................          B1CONR.rxful=0; 
*
1D9C:  MOVLB  E
1D9E:  BCF    x90.7
*
2B30:  MOVLB  E
2B32:  BCF    x90.7
....................          CAN_INT_RXB1IF=0; 
*
1DA0:  BCF    F77.1
*
2B34:  BCF    F77.1
....................          break; 
*
1DA2:  MOVLB  0
1DA4:  BRA    1DCC
*
2B36:  MOVLB  0
2B38:  BRA    2B60
....................       case 4: 
....................          B2CONR.rxful=0; 
*
1DA6:  MOVLB  E
1DA8:  BCF    xA0.7
*
2B3A:  MOVLB  E
2B3C:  BCF    xA0.7
....................          CAN_INT_RXB1IF=0; 
*
1DAA:  BCF    F77.1
*
2B3E:  BCF    F77.1
....................          break; 
*
1DAC:  MOVLB  0
1DAE:  BRA    1DCC
*
2B40:  MOVLB  0
2B42:  BRA    2B60
....................       case 5: 
....................          B3CONR.rxful=0; 
*
1DB0:  MOVLB  E
1DB2:  BCF    xB0.7
*
2B44:  MOVLB  E
2B46:  BCF    xB0.7
....................          CAN_INT_RXB1IF=0; 
*
1DB4:  BCF    F77.1
*
2B48:  BCF    F77.1
....................          break; 
*
1DB6:  MOVLB  0
1DB8:  BRA    1DCC
*
2B4A:  MOVLB  0
2B4C:  BRA    2B60
....................       case 6: 
....................          B4CONR.rxful=0; 
*
1DBA:  MOVLB  E
1DBC:  BCF    xC0.7
*
2B4E:  MOVLB  E
2B50:  BCF    xC0.7
....................          CAN_INT_RXB1IF=0; 
*
1DBE:  BCF    F77.1
*
2B52:  BCF    F77.1
....................          break; 
*
1DC0:  MOVLB  0
1DC2:  BRA    1DCC
*
2B54:  MOVLB  0
2B56:  BRA    2B60
....................       case 7: 
....................          B5CONR.rxful=0; 
*
1DC4:  MOVLB  E
1DC6:  BCF    xD0.7
*
2B58:  MOVLB  E
2B5A:  BCF    xD0.7
....................          CAN_INT_RXB1IF=0; 
*
1DC8:  BCF    F77.1
*
2B5C:  BCF    F77.1
....................          break; 
*
1DCA:  MOVLB  0
*
2B5E:  MOVLB  0
....................    } 
....................  
....................    stat.inv=CAN_INT_IRXIF; 
*
1DCC:  BCF    0C.2
1DCE:  BTFSC  F77.7
1DD0:  BSF    0C.2
*
2B60:  BCF    0C.2
2B62:  BTFSC  F77.7
2B64:  BSF    0C.2
....................    CAN_INT_IRXIF = 0; 
*
1DD2:  BCF    F77.7
*
2B66:  BCF    F77.7
....................  
....................    // return to default addressing 
....................    if(curfunmode==CAN_FUN_OP_LEGACY) 
*
1DD4:  MOVF   06,F
1DD6:  BNZ   1DE0
*
2B68:  MOVF   06,F
2B6A:  BNZ   2B74
....................       CANCON.win=CAN_WIN_RX0; 
*
1DD8:  MOVLW  F1
1DDA:  ANDWF  F6F,W
1DDC:  MOVWF  F6F
1DDE:  BRA    1DE8
*
2B6C:  MOVLW  F1
2B6E:  ANDWF  F6F,W
2B70:  MOVWF  F6F
2B72:  BRA    2B7C
....................    else 
....................       ECANCON.ewin=RX0; 
*
1DE0:  MOVLW  E0
1DE2:  ANDWF  F72,W
1DE4:  IORLW  10
1DE6:  MOVWF  F72
*
2B74:  MOVLW  E0
2B76:  ANDWF  F72,W
2B78:  IORLW  10
2B7A:  MOVWF  F72
....................  
....................    #if CAN_DO_DEBUG 
....................       can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................       can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................       if ((len)&&(!stat.rtr)) 
....................       { 
....................          data-=len; 
....................          can_debug("\r\n    DATA = "); 
....................          for (i=0;i<len;i++) 
....................          { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................          } 
....................       } 
....................       can_debug("\r\n"); 
....................    #endif 
....................  
....................    return(1); 
*
1DE8:  MOVLW  01
1DEA:  MOVWF  01
1DEC:  MOVLB  E
*
2B7C:  MOVLW  01
2B7E:  MOVWF  01
2B80:  MOVLB  E
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_b_transfer: mode 1 & 2 
.................... // 
.................... // Sets one of the 6 programmable buffers to be a transfer buffer.  This uses 
.................... // a simple bitwise operation so that more than one buffer can be set at a 
.................... // time. 
.................... // 
.................... // The register that contains the TX/RX information is BSEL0 and the control 
.................... //   bits take up the 6 most significant bits.  Therefore a value of 0x04 would 
.................... //   set B0 as a transmit buffer while a value of 0xFC would set all of the 
.................... // programmable buffers to transmit buffers. 
.................... // 
.................... //   Parameters: 
.................... //      b - the buffer which is to become a transfer buffer 
.................... //       enumerated as - B0,B1,B2,B3,B4,B5 
.................... // 
.................... // More information can be found on the programmable buffers in the PIC18F4580 
.................... //   datasheet, section 23.5.3 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_enable_b_transfer(PROG_BUFFER b) 
.................... { 
....................    unsigned int8 temp; 
....................  
....................    temp=BSEL0; 
....................    temp|=b; 
....................  
....................    BSEL0=temp; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_b_receiver: mode 1 & 2 
.................... // 
.................... // Sets one of the 6 programmable buffers to be a receiver buffer.  This uses 
.................... // a simple bitwise operation so that more than one buffer can be set at a 
.................... // time. 
.................... // 
.................... // The register that contains the TX/RX information is BSEL0 and the control 
.................... //   bits take up the 6 most significant bits.  Therefore a value of 0x04 would 
.................... //   set B0 as a receive buffer while a value of 0xFC would set all of the 
.................... // programmable buffers to receive buffers. 
.................... // 
.................... // Parameters: 
.................... //    b - the buffer which is to become a receiver buffer 
.................... //       enumerated as - B0,B1,B2,B3,B4,B5 
.................... // 
.................... // returns: 
.................... //      void 
.................... // 
.................... // More information can be found on the programmable buffers in the PIC18F4580 
.................... // datasheet, section 23.5.3 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_enable_b_receiver(PROG_BUFFER b) 
.................... { 
....................    unsigned int8 temp; 
....................  
....................    temp=BSEL0; 
....................    temp&=~b; 
....................  
....................    BSEL0=temp; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_rtr: mode 1 & 2 
.................... // 
.................... // Prepares one of the programmable registers to be used as an Auto-rtr buffer 
.................... //   This function allows for multiple rtr enables. 
.................... // 
.................... // Parameters: 
.................... //      b - the programmable buffer to be set to Auto-rtr mode 
.................... //       enumerated as - B0,B1,B2,B3,B4,B5 
.................... // 
.................... //      b=0x04 - B0 rtr enable 
.................... //      b=0x08 - B1 rtr enable 
.................... //      b=0x10 - B2 rtr enable 
.................... //      b=0x20 - B3 rtr enable 
.................... //    b=0x40 - B4 rtr enable 
.................... //      b=0x80 -   B5 rtr enable 
.................... // 
.................... //      any logical and (&) combination of the above will also work 
.................... // 
.................... //      b = 0x04 & 0x80 = 0x84 - B0 and B5 rtr enable 
.................... // 
.................... // returns: 
.................... //     void 
.................... // 
.................... // More information can be found on Auto-rtr in the PIC18F4580 datasheet, 
.................... //   section 23.5.4 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_enable_rtr(PROG_BUFFER b) 
.................... { 
....................  
....................    can_enable_b_transfer ( b ); 
....................  
....................    if(bit_test(b,2)) 
....................       B0CONTA|=0x04; 
....................    if(bit_test(b,3)) 
....................       B1CONTA|=0x04; 
....................    if(bit_test(b,4)) 
....................       B2CONTA|=0x04; 
....................    if(bit_test(b,5)) 
....................       B3CONTA|=0x04; 
....................    if(bit_test(b,6)) 
....................       B4CONTA|=0x04; 
....................    if(bit_test(b,7)) 
....................       B5CONTA|=0x04; 
....................  
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_disable_rtr: mode 1 & 2 
.................... // 
.................... // disables certain programmable registers from being used as Auto-rtr buffers 
.................... //   This function allows for multiple rtr disables. 
.................... // 
.................... // Parameters: 
.................... //      b - the programmable buffer to be set to Auto-rtr mode 
.................... //       enumerated as B0,B1,B2,B3,B4,B5 
.................... // 
.................... //      b=0x04 - B0 rtr disable 
.................... //      b=0x08 - B1 rtr disable 
.................... //      b=0x10 - B2 rtr disable 
.................... //      b=0x20 - B3 rtr disable 
.................... //    b=0x40 - B4 rtr disable 
.................... //      b=0x80 -   B5 rtr disable 
.................... // 
.................... //      any logical or (|) combination of the above will also work 
.................... // 
.................... //      b = 0x04 | 0x80 = 0x84 - B0 and B5 rtr disable 
.................... // 
.................... // returns: 
.................... //     void 
.................... // 
.................... // More information can be found on Auto-rtr in the PIC18F4580 datasheet, 
.................... //   section 23.5.4 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_disable_rtr(PROG_BUFFER b) 
.................... { 
....................    if(bit_test(b,2)) 
....................       B0CONTA&=0xfb; 
....................    if(bit_test(b,3)) 
....................       B1CONTA&=0xfb; 
....................    if(bit_test(b,4)) 
....................       B2CONTA&=0xfb; 
....................    if(bit_test(b,5)) 
....................       B3CONTA&=0xfb; 
....................    if(bit_test(b,6)) 
....................       B4CONTA&=0xfb; 
....................    if(bit_test(b,7)) 
....................       B5CONTA&=0xfb; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_load_rtr: mode 1 & 2 
.................... // 
.................... //   Loads a SINGLE b buffer with data to be sent on the occurrence of an rtr. 
.................... // 
.................... // Parameters: 
.................... // 
.................... //      b - The programmable buffer to be filled 
.................... //       enumerated as - B0,B1,B2,B3,B4,B5 
.................... //      data - the address of the first data byte 
.................... //      len - the number of data bytes to be copied 
.................... // 
.................... // Returns: 
.................... //      void 
.................... // 
.................... //   Note, the programmer must set the appropriate rtr registers in order for the 
.................... //         rtr function to work.  This function does not set any of those 
.................... //         registers.  For example, to enable B0 as an Auto-rtr buffer, the 
.................... //         functions: 
.................... // 
.................... //         can_enable_b_transfer(B0); 
.................... //         can_enable_rtr(B0); 
.................... //         function to link acceptance filter to B0 
.................... // 
.................... //         need to be called. 
.................... // 
.................... //   can_load_rtr does no damage to the current mode of the ECAN 
.................... // 
.................... // More information on the Auto-rtr can be found in the PIC18F4580 datasheet 
.................... // section 23.5.4 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_load_rtr (PROG_BUFFER b, unsigned int *data, unsigned int len) 
.................... { 
....................  
....................    unsigned int *ptr; 
....................  
....................    //do no damage to the current mode; 
....................    curmode = CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................  
....................    if(bit_test(b,2)) 
....................    { 
....................       ptr=&B0D0; 
....................       B0DLCT=len; 
....................    } 
....................    else if (bit_test(b,3)) 
....................    { 
....................       ptr=&B1D0; 
....................       B1DLCT=len; 
....................    } 
....................    else if (bit_test(b,4)) 
....................    { 
....................       ptr=&B2D0; 
....................       B2DLCT=len; 
....................    } 
....................    else if (bit_test(b,5)) 
....................    { 
....................       ptr=&B3D0; 
....................       B3DLCT=len; 
....................    } 
....................    else if (bit_test(b,6)) 
....................    { 
....................       ptr=&B4D0; 
....................       B4DLCT=len; 
....................    } 
....................    else if (bit_test(b,7)) 
....................    { 
....................       ptr=&B5D0; 
....................       B5DLCT=len; 
....................    } 
....................    else 
....................       return; 
....................  
....................    for(;len>0;len--) { 
....................       *ptr=*data; 
....................       ptr++; 
....................       data++; 
....................    } 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_filter: mode 1 , 2 & 3 
.................... // 
.................... //   Enables a given acceptance filter 
.................... // 
.................... // Parameters: 
.................... //      filter - the filter that is to be enabled 
.................... //         enumerated as - RXF0EN-RXF15EN 
.................... // 
.................... // Returns: 
.................... //    void 
.................... // 
.................... // More information can be found on Acceptance Filters in the PIC18F4580 
.................... // datasheet, Section 23.8 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_enable_filter(unsigned long filter) 
.................... { 
....................    unsigned long *ptr; 
....................  
....................    curmode=CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................  
....................    ptr = &RXFCON0; 
....................  
....................    *ptr|=filter; 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_disable_filter: mode 0 , 1 & 2 
.................... // 
.................... // Disables a given acceptance filter 
.................... // 
.................... // Parameters: 
.................... //      filter - the filter that is to be disabled 
.................... //        enumerated as - RXF0EN-RXF15EN 
.................... // 
.................... // Returns: 
.................... //      void; 
.................... // 
.................... // More information can be found on Acceptance Filters in the PIC18F4580 
.................... // datasheet, Section 23.8 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_disable_filter(unsigned long filter) 
.................... { 
....................    unsigned long *ptr; 
....................  
....................    curmode=CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................  
....................    ptr = &RXFCON0; 
....................  
....................    *ptr&=~filter; 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_associate_filter_to_buffer: mode 1 & 2 
.................... // 
.................... // Associates a given buffer with a given filter register 
.................... // 
.................... // Parameters: 
.................... //      buffer - the buffer that is to be associated with the filter 
.................... //        enumerated as 
.................... //               ARXB0-ARXB1 - Dedicated receive buffers RX0-RX1 
.................... //               AB0-AB5 - Programmable receive buffers B0-B5 
.................... // 
.................... //      filter - the filter that is to be associated with the buffer 
.................... //         enumerated as 
.................... //               F0BP-F15BP - Filters 0 - 15 
.................... // 
.................... // 
.................... // Returns: 
.................... //      void 
.................... // 
.................... //   More information can be found on Acceptance Filters in the PIC18F4580 
.................... // datasheet, Section 23.8 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_associate_filter_to_buffer(CAN_FILTER_ASSOCIATION_BUFFERS buffer, CAN_FILTER_ASSOCIATION filter) 
.................... { 
....................    unsigned int *ptr; 
....................  
....................    curmode=CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................  
....................    ptr = &RXFBCON0 + (filter >> 1); 
....................  
....................    if((filter & 0x01) == 1) 
....................    { 
....................       *ptr&=0x0f; 
....................       *ptr|=buffer<<4; 
....................    } 
....................    else 
....................    { 
....................       *ptr&=0xf0; 
....................       *ptr|=buffer; 
....................    } 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_associate_filter_to_mask 
.................... // 
.................... //   Associates a given filter to a given mask 
.................... // 
.................... //   Parameters: 
.................... //      mask - the mask that is to be associated with the filter 
.................... //         enumerated as 
.................... //            ACCEPTANCE_MASK_0 
.................... //            ACCEPTANCE_MASK_1 
.................... //            FILTER_15 
.................... //            NO_MASK 
.................... // 
.................... //      filter - the filter that is to be associated with the mask 
.................... //         enumerated as 
.................... //               F0BP-F15BP - Filters 0 - 15 
.................... // 
.................... // 
.................... //   Returns: 
.................... //      void 
.................... // 
.................... // More information can be found on Acceptance Filters in the PIC18F4580 
.................... // datasheet, Section 23.8 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_associate_filter_to_mask(CAN_MASK_FILTER_ASSOCIATE mask, CAN_FILTER_ASSOCIATION filter) 
.................... { 
....................    unsigned int *ptr; 
....................  
....................    curmode = CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................  
....................    ptr = &MSEL0 + (filter >> 2); 
....................  
....................    if((filter & 0x03)==0) 
....................    { 
....................       *ptr&=0xfc; 
....................       *ptr|=mask; 
....................    } 
....................    else if((filter & 0x03)==1) 
....................    { 
....................       *ptr&=0xf3; 
....................       *ptr|=mask<<2; 
....................    } 
....................    else if((filter & 0x03)==2) 
....................    { 
....................       *ptr&=0xcf; 
....................       *ptr|=mask<<4; 
....................    } 
....................    else if((filter & 0x03)==3) 
....................    { 
....................       *ptr&=0x3f; 
....................       *ptr|=mask<<6; 
....................    } 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_FIFO_getd 
.................... // 
.................... // Retrieves data in Mode 2 
.................... // 
.................... // Parameters: 
.................... //      id - The ID of the sender 
.................... //      data - Address of the array to store the data in 
.................... //      len - number of data bytes to read 
.................... //      stat - status structure to return information about the receive register 
.................... // 
.................... // Returns: 
.................... //      int1 - TRUE if there was data in the buffer, FALSE if there wasn't 
.................... // 
.................... // More information can be found on the FIFO mode in the PIC18F4580 datasheet 
.................... // section 23.7.3 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 can_fifo_getd(unsigned int32 &id, unsigned int *data, unsigned int &len, struct rx_stat &stat ) 
.................... { 
....................  
....................    unsigned int i; 
....................    unsigned int *ptr; 
....................  
....................    if(!COMSTAT_MODE_2.fifoempty)          // if there is no data in the buffer 
....................       return(0);                          // return false; 
....................  
....................    ECANCON.ewin=CANCON_MODE_2.fp | 0x10; 
....................    stat.buffer=CANCON_MODE_2.fp; 
....................  
....................    //CAN_INT_RXB1IF=0;                    // moved to end of function 
....................  
....................    stat.err_ovfl=COMSTAT_MODE_2.rxnovfl; 
....................    COMSTAT_MODE_2.rxnovfl = 0; 
....................    stat.filthit=RXB0CON_MODE_2.filthit; 
....................  
....................    len = RXBaDLC.dlc; 
....................    stat.rtr=RXBaDLC.rtr; 
....................  
....................    stat.ext=TXRXBaSIDL.ext; 
....................    id=can_get_id(TXRXBaID,stat.ext); 
....................  
....................    ptr = &TXRXBaD0; 
....................    for ( i = 0; i < len; i++ ) { 
....................        *data = *ptr; 
....................        data++; 
....................        ptr++; 
....................    } 
....................  
....................    RXB0CON_MODE_2.rxful=0; 
....................  
....................    CAN_INT_RXB1IF=0; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    stat.inv=CAN_INT_IRXIF; 
....................    CAN_INT_IRXIF = 0; 
....................  
....................    return(1); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_t0_putd - can_t2_putd 
.................... // can_b0_putd - can_b5_putd 
.................... // 
.................... // places data to be transferred in a specified buffer 
.................... // 
.................... // Parameters: 
.................... //      id - id that will be sent with the data 
.................... //    data - pointer to the data 
.................... //      len - number of data bytes (0-8) 
.................... //      pri - priority (0-3) 
.................... //      ext - extended or not 
.................... //    rtr - request remote transfer 
.................... // 
.................... // Returns: 
.................... //      TRUE if data is successfully loaded into the buffer 
.................... //      FALSE if data can not be loaded into the buffer 
.................... // 
.................... //   Notes 
.................... //      - make sure that the desired buffer is set to be a transfer buffer 
.................... //        using the can_enable_b_transfer ( ) function 
.................... // 
.................... // More information can be found on using the transfer buffers in the PICF4580 
.................... //   datasheet section 23.6 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // transfer buffer 0 
.................... int1 can_t0_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *ptr; 
....................  
....................    if(TXB0CON.txreq) 
....................       return ( FALSE ); 
....................  
....................    can_set_id( TXB0ID, id, ext ); 
....................  
....................    TXB0DLC.dlc = len; 
....................  
....................    TXB0CON.txpri = pri; 
....................  
....................    TXB0DLC.rtr = rtr; 
....................  
....................    ptr = &TXB0D0; 
....................  
....................    for(;len>0;len--) 
....................    { 
....................       *ptr = *data; 
....................       ptr++; 
....................       data++; 
....................    } 
....................  
....................    TXB0CON.txreq = 1; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // transfer buffer 1 
.................... int1 can_t1_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *ptr; 
....................  
....................    if(TXB1CON.txreq) 
....................       return ( FALSE ); 
....................  
....................    can_set_id( TXB1ID, id, ext ); 
....................  
....................    TXB1DLC.dlc = len; 
....................  
....................    TXB1CON.txpri = pri; 
....................  
....................    TXB1DLC.rtr = rtr; 
....................  
....................    ptr = &TXB1D0; 
....................  
....................    for(;len>0;len--) 
....................    { 
....................       *ptr = *data; 
....................       ptr++; 
....................       data++; 
....................    } 
....................  
....................    TXB1CON.txreq = 1; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // transfer buffer 2 
.................... int1 can_t2_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *ptr; 
....................  
....................    if(TXB2CON.txreq) 
....................       return ( FALSE ); 
....................  
....................    can_set_id( TXB2ID, id, ext ); 
....................  
....................    TXB2DLC.dlc = len; 
....................  
....................    TXB2CON.txpri = pri; 
....................  
....................    TXB2DLC.rtr = rtr; 
....................  
....................    ptr = &TXB2D0; 
....................  
....................    for(;len>0;len--) 
....................    { 
....................       *ptr = *data; 
....................       ptr++; 
....................       data++; 
....................    } 
....................  
....................    TXB2CON.txreq = 1; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // programmable buffer 0 
.................... int1 can_b0_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B0CONT.txreq || !BSEL0.b0txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX0; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................     for (;len>0;len--) 
....................     { 
....................       *txd0=*data; 
....................       txd0++; 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
....................  
.................... } 
....................  
.................... // programmable buffer 1 
.................... int1 can_b1_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B1CONT.txreq || !BSEL0.b1txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX1; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................     for (;len>0;len--) 
....................     { 
....................       *txd0=*data; 
....................       txd0++; 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // programmable buffer 2 
.................... int1 can_b2_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B2CONT.txreq || !BSEL0.b2txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX2; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................     for (;len>0;len--) 
....................     { 
....................       *txd0=*data; 
....................       txd0++; 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // programmable buffer 3 
.................... int1 can_b3_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B3CONT.txreq || !BSEL0.b3txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX3; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................     for (;len>0;len--) 
....................     { 
....................       *txd0=*data; 
....................       txd0++; 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
....................  
.................... } 
....................  
.................... // programmable buffer 4 
.................... int1 can_b4_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B4CONT.txreq || !BSEL0.b4txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX4; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................     for (;len>0;len--) 
....................     { 
....................       *txd0=*data; 
....................       txd0++; 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // programmable buffer 5 
.................... int1 can_b5_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B5CONT.txreq || !BSEL0.b5txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX5; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................    for (;len>0;len--) 
....................    { 
....................      *txd0=*data; 
....................      txd0++; 
....................      data++; 
....................    } 
....................  
....................    txd0=&B5D0; 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
....................  
....................  
.................... #define CAN_ALARM_ID          20  
.................... #define CAN_KEY_ID               21 
.................... #define CAN_LIGHTSTATION_ID   22 
.................... #define CAN_BROADCAST_ID   1 
....................  
.................... ///-------EEPROM MAP--------------- 
.................... #define EEPROM_LINE1            0x00 
.................... #define EEPROM_LINE2            0x01 
.................... #define EEPROM_LINE3            0x02 
.................... #define EEPROM_LINE4            0x03 
.................... #define EEPROM_LINECAN          0x04 
....................  
.................... #define EEPROM_LINE1_DELAY      0x05 
.................... #define EEPROM_LINE2_DELAY      0x06 
.................... #define EEPROM_LINE3_DELAY      0x07 
.................... #define EEPROM_LINE4_DELAY      0x08 
.................... #define EEPROM_LINECAN_DELAY    0x09 
....................  
.................... #define EEPROM_CARD1            0x10 
.................... #define EEPROM_CARD2            0x11 
.................... #define EEPROM_CARD3            0x12 
.................... #define EEPROM_CARD4            0x13 
.................... #define EEPROM_CARD5            0x14 
.................... #define EEPROM_CARD6            0x15 
.................... #define EEPROM_CARD7            0x16 
.................... #define EEPROM_CARD8            0x17 
.................... #define EEPROM_CARD9            0x18 
.................... #define EEPROM_CARD10           0x19 
....................  
.................... #define EEPROM_SIRENE_DELAY    0x20 
.................... #define EEPROM_REGSTATE            0x21 
....................  
.................... ///ZMIENNE GLOBALNE 
.................... unsigned char state; //stan urzadzenia aktualny; alarm itp. 
.................... unsigned char reg_state; //stan urzadzenia zarejestrowany; alarm itp. 
....................  
.................... //zmienne dla magistrali CAN 
.................... struct rx_stat rxstat;  
.................... int32 rx_id;  
.................... int32 tx_id;  
.................... int8 rx_len;                 
.................... unsigned int8 buffer[8]; 
.................... unsigned int8 buffer2[8]; 
....................  
....................  
.................... //zmienne zegara 
.................... byte sec,min,hour; 
.................... byte wassec=0; 
.................... byte sirene_timer=0; 
....................  
.................... int8 alarm_delay=-1; 
....................  
.................... #include "conversion.c" 
.................... // Convert normal decimal numbers to binary coded decimal 
.................... byte decToBcd(byte val) 
.................... { 
....................   return ( (val/10*16) + (val%10) ); 
*
2004:  MOVFF  30,3E
2008:  MOVLW  0A
200A:  MOVWF  3F
200C:  CALL   0B1A
2010:  MOVF   01,W
2012:  MULLW  10
2014:  MOVFF  FF3,31
2018:  MOVFF  30,3E
201C:  MOVLW  0A
201E:  MOVWF  3F
2020:  CALL   0B1A
2024:  MOVF   00,W
2026:  ADDWF  31,W
2028:  MOVWF  01
202A:  RETURN 0
.................... } 
....................  
.................... // Convert binary coded decimal to normal decimal numbers 
.................... byte bcdToDec(byte val) 
.................... { 
....................   return ( (val/16*10) + (val%16) ); 
*
0AC4:  SWAPF  31,W
0AC6:  MOVWF  00
0AC8:  MOVLW  0F
0ACA:  ANDWF  00,F
0ACC:  MOVF   00,W
0ACE:  MULLW  0A
0AD0:  MOVFF  FF3,32
0AD4:  MOVF   31,W
0AD6:  ANDLW  0F
0AD8:  ADDWF  32,W
0ADA:  MOVWF  01
0ADC:  RETURN 0
.................... } 
....................  
.................... #include "ds1307.c" 
.................... /* 
.................... ZEGAR CZASU RZECZYWISTEGO  
....................   DS1307 
.................... */   
....................  
.................... #define DS1307_SDA  PIN_C4 
.................... #define DS1307_SCL  PIN_C3 
....................  
.................... #use i2c(master, sda=DS1307_SDA, scl=DS1307_SCL) 
*
09C0:  MOVLW  08
09C2:  MOVWF  01
09C4:  BRA    09C6
09C6:  BCF    F8B.3
09C8:  BCF    F94.3
09CA:  BRA    09CC
09CC:  NOP   
09CE:  RLCF   35,F
09D0:  BCF    F8B.4
09D2:  BTFSC  FD8.0
09D4:  BSF    F94.4
09D6:  BTFSS  FD8.0
09D8:  BCF    F94.4
09DA:  BSF    F94.3
09DC:  BTFSS  F82.3
09DE:  BRA    09DC
09E0:  DECFSZ 01,F
09E2:  BRA    09C4
09E4:  BRA    09E6
09E6:  BCF    F8B.3
09E8:  BCF    F94.3
09EA:  NOP   
09EC:  BSF    F94.4
09EE:  BRA    09F0
09F0:  NOP   
09F2:  BRA    09F4
09F4:  NOP   
09F6:  BSF    F94.3
09F8:  BTFSS  F82.3
09FA:  BRA    09F8
09FC:  CLRF   01
09FE:  BRA    0A00
0A00:  NOP   
0A02:  BTFSC  F82.4
0A04:  BSF    01.0
0A06:  BCF    F8B.3
0A08:  BCF    F94.3
0A0A:  BCF    F8B.4
0A0C:  BCF    F94.4
0A0E:  RETURN 0
0A10:  MOVLW  08
0A12:  MOVWF  33
0A14:  MOVFF  00,34
0A18:  BSF    F94.4
0A1A:  BRA    0A1C
0A1C:  NOP   
0A1E:  BSF    F94.3
0A20:  BTFSS  F82.3
0A22:  BRA    0A20
0A24:  BTFSC  F82.4
0A26:  BSF    FD8.0
0A28:  BTFSS  F82.4
0A2A:  BCF    FD8.0
0A2C:  RLCF   01,F
0A2E:  BRA    0A30
0A30:  BCF    F94.3
0A32:  BCF    F8B.3
0A34:  DECFSZ 33,F
0A36:  BRA    0A18
0A38:  BSF    F94.4
0A3A:  BRA    0A3C
0A3C:  NOP   
0A3E:  BCF    F8B.4
0A40:  MOVF   34,W
0A42:  BTFSS  FD8.2
0A44:  BCF    F94.4
0A46:  NOP   
0A48:  BSF    F94.3
0A4A:  BTFSS  F82.3
0A4C:  BRA    0A4A
0A4E:  BRA    0A50
0A50:  BCF    F8B.3
0A52:  BCF    F94.3
0A54:  BRA    0A56
0A56:  NOP   
0A58:  BCF    F8B.4
0A5A:  BCF    F94.4
0A5C:  GOTO   0AA6 (RETURN)
....................  
.................... //========================== 
.................... // initial DS1307 
.................... //========================== 
.................... void init_DS1307() 
.................... { 
....................    output_float(DS1307_SCL); 
....................    output_float(DS1307_SDA); 
.................... } 
.................... //========================== 
.................... // write data one byte to 
.................... // DS1307 
.................... //========================== 
.................... void write_DS1307(byte address, BYTE data) 
.................... { 
....................    short int status; 
....................    char x; 
....................    i2c_start(); 
*
202C:  BSF    F94.4
202E:  BRA    2030
2030:  BSF    F94.3
2032:  BRA    2034
2034:  NOP   
2036:  BCF    F8B.4
2038:  BCF    F94.4
203A:  BRA    203C
203C:  BCF    F8B.3
203E:  BCF    F94.3
....................    i2c_write(0xd0); 
2040:  MOVLW  D0
2042:  MOVWF  35
2044:  CALL   09C0
....................    i2c_write(address); 
2048:  MOVFF  31,35
204C:  CALL   09C0
....................    i2c_write(data); 
2050:  MOVFF  32,35
2054:  CALL   09C0
....................    i2c_stop(); 
2058:  BCF    F94.4
205A:  NOP   
205C:  BSF    F94.3
205E:  BTFSS  F82.3
2060:  BRA    205E
2062:  BRA    2064
2064:  BRA    2066
2066:  NOP   
2068:  BSF    F94.4
206A:  BRA    206C
....................    i2c_start(); 
206C:  BSF    F94.4
206E:  BRA    2070
2070:  BSF    F94.3
2072:  BRA    2074
2074:  NOP   
2076:  BCF    F8B.4
2078:  BCF    F94.4
207A:  BRA    207C
207C:  BCF    F8B.3
207E:  BCF    F94.3
....................    status=i2c_write(0xd0); 
2080:  MOVLW  D0
2082:  MOVWF  35
2084:  CALL   09C0
2088:  MOVF   01,W
208A:  BCF    33.0
208C:  BTFSC  01.0
208E:  BSF    33.0
....................    x = 0xd0; 
2090:  MOVLW  D0
2092:  MOVWF  34
....................    while(status==1 || x<5) 
2094:  BTFSC  33.0
2096:  BRA    209E
2098:  MOVF   34,W
209A:  SUBLW  04
209C:  BNC   20CA
....................    { 
....................       i2c_start(); 
209E:  BSF    F94.4
20A0:  BRA    20A2
20A2:  BSF    F94.3
20A4:  BRA    20A6
20A6:  NOP   
20A8:  BTFSS  F82.3
20AA:  BRA    20A8
20AC:  BCF    F8B.4
20AE:  BCF    F94.4
20B0:  BRA    20B2
20B2:  BCF    F8B.3
20B4:  BCF    F94.3
....................       status=i2c_write(0xd0); 
20B6:  MOVLW  D0
20B8:  MOVWF  35
20BA:  CALL   09C0
20BE:  MOVF   01,W
20C0:  BCF    33.0
20C2:  BTFSC  01.0
20C4:  BSF    33.0
....................       x++; 
20C6:  INCF   34,F
20C8:  BRA    2094
....................    } 
20CA:  RETURN 0
.................... } 
.................... //========================== 
.................... // read data one byte from DS1307 
.................... //========================== 
.................... BYTE read_DS1307(byte address) 
.................... { 
....................    BYTE data; 
....................    i2c_start(); 
*
0A60:  BSF    F94.4
0A62:  BRA    0A64
0A64:  BSF    F94.3
0A66:  BRA    0A68
0A68:  NOP   
0A6A:  BTFSS  F82.3
0A6C:  BRA    0A6A
0A6E:  BCF    F8B.4
0A70:  BCF    F94.4
0A72:  BRA    0A74
0A74:  BCF    F8B.3
0A76:  BCF    F94.3
....................    i2c_write(0xd0); 
0A78:  MOVLW  D0
0A7A:  MOVWF  35
0A7C:  RCALL  09C0
....................    i2c_write(address); 
0A7E:  MOVFF  30,35
0A82:  RCALL  09C0
....................    i2c_start(); 
0A84:  BSF    F94.4
0A86:  BRA    0A88
0A88:  BSF    F94.3
0A8A:  BRA    0A8C
0A8C:  NOP   
0A8E:  BTFSS  F82.3
0A90:  BRA    0A8E
0A92:  BCF    F8B.4
0A94:  BCF    F94.4
0A96:  BRA    0A98
0A98:  BCF    F8B.3
0A9A:  BCF    F94.3
....................    i2c_write(0xd1); 
0A9C:  MOVLW  D1
0A9E:  MOVWF  35
0AA0:  RCALL  09C0
....................    data=i2c_read(0); 
0AA2:  CLRF   00
0AA4:  BRA    0A10
0AA6:  MOVFF  01,31
....................    i2c_stop(); 
0AAA:  BCF    F94.4
0AAC:  NOP   
0AAE:  BSF    F94.3
0AB0:  BTFSS  F82.3
0AB2:  BRA    0AB0
0AB4:  BRA    0AB6
0AB6:  BRA    0AB8
0AB8:  NOP   
0ABA:  BSF    F94.4
0ABC:  BRA    0ABE
....................    return(data); 
0ABE:  MOVFF  31,01
0AC2:  RETURN 0
.................... } 
....................  
.................... #include "rtc.c" 
.................... //-------------ZEGAR-------------- 
.................... void read_time() 
.................... { 
....................    sec = bcdToDec(read_ds1307 (0)); // read second 
*
0ADE:  CLRF   30
0AE0:  RCALL  0A60
0AE2:  MOVFF  01,30
0AE6:  MOVFF  01,31
0AEA:  RCALL  0AC4
0AEC:  MOVFF  01,26
....................    min = bcdToDec(read_ds1307 (1)); // read minute 
0AF0:  MOVLW  01
0AF2:  MOVWF  30
0AF4:  RCALL  0A60
0AF6:  MOVFF  01,30
0AFA:  MOVFF  01,31
0AFE:  RCALL  0AC4
0B00:  MOVFF  01,27
....................    hour = bcdToDec(read_ds1307 (2)); // read hour 
0B04:  MOVLW  02
0B06:  MOVWF  30
0B08:  RCALL  0A60
0B0A:  MOVFF  01,30
0B0E:  MOVFF  01,31
0B12:  RCALL  0AC4
0B14:  MOVFF  01,28
0B18:  RETURN 0
.................... } 
....................  
.................... void set_time() 
.................... { 
....................    write_ds1307 (4, decToBcd(1)); //day 
*
20CC:  MOVLW  01
20CE:  MOVWF  30
20D0:  RCALL  2004
20D2:  MOVFF  01,30
20D6:  MOVLW  04
20D8:  MOVWF  31
20DA:  MOVFF  01,32
20DE:  RCALL  202C
....................    write_ds1307 (5, decToBcd(1)); //month 
20E0:  MOVLW  01
20E2:  MOVWF  30
20E4:  RCALL  2004
20E6:  MOVFF  01,30
20EA:  MOVLW  05
20EC:  MOVWF  31
20EE:  MOVFF  01,32
20F2:  RCALL  202C
....................    write_ds1307 (6, decToBcd(0)); //year 
20F4:  CLRF   30
20F6:  RCALL  2004
20F8:  MOVFF  01,30
20FC:  MOVLW  06
20FE:  MOVWF  31
2100:  MOVFF  01,32
2104:  RCALL  202C
....................    write_ds1307 (2, decToBcd(hour)); //hour; 
2106:  MOVFF  28,30
210A:  RCALL  2004
210C:  MOVFF  01,30
2110:  MOVLW  02
2112:  MOVWF  31
2114:  MOVFF  01,32
2118:  RCALL  202C
....................    write_ds1307 (1, decToBcd(min)); //minute 
211A:  MOVFF  27,30
211E:  RCALL  2004
2120:  MOVFF  01,30
2124:  MOVLW  01
2126:  MOVWF  31
2128:  MOVFF  01,32
212C:  RCALL  202C
....................    write_ds1307 (0, decToBcd(0)); //second 
212E:  CLRF   30
2130:  RCALL  2004
2132:  MOVFF  01,30
2136:  CLRF   31
2138:  MOVFF  01,32
213C:  RCALL  202C
213E:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void time_config(){ 
....................         read_time(); 
2140:  CALL   0ADE
....................         printf("%02d:%02d:%02d \n", hour,min,sec); 
2144:  MOVFF  28,30
2148:  MOVLW  01
214A:  MOVWF  31
214C:  CALL   0B42
2150:  MOVLW  3A
2152:  BTFSS  F9E.4
2154:  BRA    2152
2156:  MOVWF  FAD
2158:  MOVFF  27,30
215C:  MOVLW  01
215E:  MOVWF  31
2160:  CALL   0B42
2164:  MOVLW  3A
2166:  BTFSS  F9E.4
2168:  BRA    2166
216A:  MOVWF  FAD
216C:  MOVFF  26,30
2170:  MOVLW  01
2172:  MOVWF  31
2174:  CALL   0B42
2178:  MOVLW  20
217A:  BTFSS  F9E.4
217C:  BRA    217A
217E:  MOVWF  FAD
2180:  MOVLW  0A
2182:  BTFSS  F9E.4
2184:  BRA    2182
2186:  MOVWF  FAD
....................         printf("h - set hour\n"); 
2188:  MOVLW  04
218A:  MOVWF  FF6
218C:  MOVLW  00
218E:  MOVWF  FF7
2190:  CALL   064E
....................         printf("m - set minute\n"); 
2194:  MOVLW  12
2196:  MOVWF  FF6
2198:  MOVLW  00
219A:  MOVWF  FF7
219C:  CALL   064E
....................         printf("(u - up, d - down, s - set)\n"); 
21A0:  MOVLW  22
21A2:  MOVWF  FF6
21A4:  MOVLW  00
21A6:  MOVWF  FF7
21A8:  CALL   064E
....................         char c=getc(); 
21AC:  CALL   126E
21B0:  MOVFF  01,2F
....................         switch (c){ 
21B4:  MOVF   2F,W
21B6:  XORLW  68
21B8:  BZ    21C0
21BA:  XORLW  05
21BC:  BZ    2238
21BE:  BRA    22AE
....................                    case 'h':  
....................                         while(c != 's'){ 
21C0:  MOVF   2F,W
21C2:  SUBLW  73
21C4:  BZ    2228
....................                                 printf("%02d:%02d \n", hour,min); 
21C6:  MOVFF  28,30
21CA:  MOVLW  01
21CC:  MOVWF  31
21CE:  CALL   0B42
21D2:  MOVLW  3A
21D4:  BTFSS  F9E.4
21D6:  BRA    21D4
21D8:  MOVWF  FAD
21DA:  MOVFF  27,30
21DE:  MOVLW  01
21E0:  MOVWF  31
21E2:  CALL   0B42
21E6:  MOVLW  20
21E8:  BTFSS  F9E.4
21EA:  BRA    21E8
21EC:  MOVWF  FAD
21EE:  MOVLW  0A
21F0:  BTFSS  F9E.4
21F2:  BRA    21F0
21F4:  MOVWF  FAD
....................                                 c = getc(); 
21F6:  CALL   126E
21FA:  MOVFF  01,2F
....................                                 if (c=='u'){ 
21FE:  MOVF   2F,W
2200:  SUBLW  75
2202:  BNZ   2212
....................                                         if (hour<25) hour = hour + 1; 
2204:  MOVF   28,W
2206:  SUBLW  18
2208:  BNC   2210
220A:  MOVLW  01
220C:  ADDWF  28,F
220E:  BRA    2212
....................                                         else hour = 0; 
2210:  CLRF   28
....................                                 } 
....................                                 if (c=='d'){ 
2212:  MOVF   2F,W
2214:  SUBLW  64
2216:  BNZ   2226
....................                                         if (hour>0) hour = hour - 1; 
2218:  MOVF   28,F
221A:  BZ    2222
221C:  MOVLW  01
221E:  SUBWF  28,F
2220:  BRA    2226
....................                                         else hour = 24; 
2222:  MOVLW  18
2224:  MOVWF  28
....................                                 } 
2226:  BRA    21C0
....................                         } 
....................                         set_time(); 
2228:  RCALL  20CC
....................                         printf("saved\n"); 
222A:  MOVLW  40
222C:  MOVWF  FF6
222E:  MOVLW  00
2230:  MOVWF  FF7
2232:  CALL   064E
....................                         break; 
2236:  BRA    22AE
....................                    case 'm':  
....................                         while(c != 's'){ 
2238:  MOVF   2F,W
223A:  SUBLW  73
223C:  BZ    22A0
....................                                 printf("%02d:%02d \n", hour,min); 
223E:  MOVFF  28,30
2242:  MOVLW  01
2244:  MOVWF  31
2246:  CALL   0B42
224A:  MOVLW  3A
224C:  BTFSS  F9E.4
224E:  BRA    224C
2250:  MOVWF  FAD
2252:  MOVFF  27,30
2256:  MOVLW  01
2258:  MOVWF  31
225A:  CALL   0B42
225E:  MOVLW  20
2260:  BTFSS  F9E.4
2262:  BRA    2260
2264:  MOVWF  FAD
2266:  MOVLW  0A
2268:  BTFSS  F9E.4
226A:  BRA    2268
226C:  MOVWF  FAD
....................                                 c = getc(); 
226E:  CALL   126E
2272:  MOVFF  01,2F
....................                                 if (c=='u'){ 
2276:  MOVF   2F,W
2278:  SUBLW  75
227A:  BNZ   228A
....................                                         if (min<59) min = min + 1; 
227C:  MOVF   27,W
227E:  SUBLW  3A
2280:  BNC   2288
2282:  MOVLW  01
2284:  ADDWF  27,F
2286:  BRA    228A
....................                                         else min = 0; 
2288:  CLRF   27
....................                                 } 
....................                                 if (c=='d'){ 
228A:  MOVF   2F,W
228C:  SUBLW  64
228E:  BNZ   229E
....................                                         if (min>0) min = min - 1; 
2290:  MOVF   27,F
2292:  BZ    229A
2294:  MOVLW  01
2296:  SUBWF  27,F
2298:  BRA    229E
....................                                         else min = 59; 
229A:  MOVLW  3B
229C:  MOVWF  27
....................                                 } 
229E:  BRA    2238
....................                         } 
....................                         set_time(); 
22A0:  RCALL  20CC
....................                         printf("saved\n"); 
22A2:  MOVLW  48
22A4:  MOVWF  FF6
22A6:  MOVLW  00
22A8:  MOVWF  FF7
22AA:  CALL   064E
....................                         break; 
....................         } 
22AE:  GOTO   28FC (RETURN)
.................... } 
....................  
....................  
.................... #include "led.c" 
....................  
....................  
.................... ///-------------LED---------------- 
.................... void blinkgreenred(int t){ 
....................    output_high(LED_RED);  
*
0670:  BCF    F92.6
0672:  BSF    F89.6
....................    output_high(LED_GREEN);   
0674:  BCF    F92.7
0676:  BSF    F89.7
....................    delay_ms(t);  
0678:  MOVFF  2F,30
067C:  RCALL  0628
....................    output_low(LED_RED);  
067E:  BCF    F92.6
0680:  BCF    F89.6
....................    output_low(LED_GREEN);  
0682:  BCF    F92.7
0684:  BCF    F89.7
0686:  RETURN 0
.................... } 
....................  
.................... void blinkgreen(int t){ 
....................    output_high(LED_GREEN);  
*
109E:  BCF    F92.7
10A0:  BSF    F89.7
....................    delay_ms(t);  
10A2:  MOVFF  2F,30
10A6:  CALL   0628
....................    output_low(LED_GREEN);  
10AA:  BCF    F92.7
10AC:  BCF    F89.7
10AE:  GOTO   10D6 (RETURN)
.................... } 
....................  
.................... void blinkred(int t){ 
....................    output_high(LED_RED);   
*
108A:  BCF    F92.6
108C:  BSF    F89.6
....................    delay_ms(t);  
108E:  MOVFF  2F,30
1092:  CALL   0628
....................    output_low(LED_RED);  
1096:  BCF    F92.6
1098:  BCF    F89.6
109A:  GOTO   10BC (RETURN)
.................... } 
....................  
.................... void led_state_display(){ 
....................         if (state == st_armed){ 
*
10B2:  DECFSZ 07,W
10B4:  BRA    10CC
....................                 blinkred(100); 
10B6:  MOVLW  64
10B8:  MOVWF  2F
10BA:  BRA    108A
....................                 delay_ms(800); 
10BC:  MOVLW  04
10BE:  MOVWF  2F
10C0:  MOVLW  C8
10C2:  MOVWF  30
10C4:  CALL   0628
10C8:  DECFSZ 2F,F
10CA:  BRA    10C0
....................         } 
....................         if (state == st_unarmed){ 
10CC:  MOVF   07,F
10CE:  BNZ   10E6
....................                 blinkgreen(100); 
10D0:  MOVLW  64
10D2:  MOVWF  2F
10D4:  BRA    109E
....................                 delay_ms(800); 
10D6:  MOVLW  04
10D8:  MOVWF  2F
10DA:  MOVLW  C8
10DC:  MOVWF  30
10DE:  CALL   0628
10E2:  DECFSZ 2F,F
10E4:  BRA    10DA
....................         } 
....................         if (state == st_alarm){ 
10E6:  MOVF   07,W
10E8:  SUBLW  02
10EA:  BNZ   10F4
....................                 blinkgreenred(500); 
10EC:  MOVLW  F4
10EE:  MOVWF  2F
10F0:  CALL   0670
....................         } 
.................... 	if (state == st_postalarm){ 
10F4:  MOVF   07,W
10F6:  SUBLW  03
10F8:  BNZ   1102
....................                 blinkgreenred(500); 
10FA:  MOVLW  F4
10FC:  MOVWF  2F
10FE:  CALL   0670
....................         } 
1102:  GOTO   2720 (RETURN)
.................... } 
....................  
....................  
.................... #include "sirene.c" 
.................... ///-------------SYRENA------------- 
....................  
.................... //konfiguracja syreny 
.................... void sirene_config(){ 
....................         printf("Sirene will be active %d min after alarm\n",read_eeprom(EEPROM_SIRENE_DELAY)); 
*
17EA:  MOVFF  FF2,30
17EE:  BCF    FF2.7
17F0:  CLRF   F75
17F2:  MOVLW  20
17F4:  MOVWF  F74
17F6:  BCF    F7F.6
17F8:  BCF    F7F.7
17FA:  BSF    F7F.0
17FC:  MOVF   F73,W
17FE:  BTFSC  30.7
1800:  BSF    FF2.7
1802:  MOVWF  31
1804:  MOVLW  50
1806:  MOVWF  FF6
1808:  MOVLW  00
180A:  MOVWF  FF7
180C:  MOVLW  16
180E:  MOVWF  38
1810:  CALL   0BF4
1814:  MOVFF  31,38
1818:  MOVLW  18
181A:  MOVWF  39
181C:  CALL   0DF8
1820:  MOVLW  68
1822:  MOVWF  FF6
1824:  MOVLW  00
1826:  MOVWF  FF7
1828:  MOVLW  11
182A:  MOVWF  38
182C:  CALL   0BF4
....................    printf("Set to 1-1min 2-2min 3-5min\n"); 
1830:  MOVLW  7A
1832:  MOVWF  FF6
1834:  MOVLW  00
1836:  MOVWF  FF7
1838:  CALL   064E
....................         char c=getc(); 
183C:  RCALL  126E
183E:  MOVFF  01,2F
....................         //1minuta 
....................         if (c=='1'){ 
1842:  MOVF   2F,W
1844:  SUBLW  31
1846:  BNZ   1876
....................             write_eeprom(EEPROM_SIRENE_DELAY,1); 
1848:  MOVF   FF2,W
184A:  MOVWF  00
184C:  BCF    FF2.7
184E:  CLRF   F75
1850:  MOVLW  20
1852:  MOVWF  F74
1854:  MOVLW  01
1856:  MOVWF  F73
1858:  BCF    F7F.6
185A:  BCF    F7F.7
185C:  BSF    F7F.2
185E:  MOVLB  F
1860:  MOVLW  55
1862:  MOVWF  F7E
1864:  MOVLW  AA
1866:  MOVWF  F7E
1868:  BSF    F7F.1
186A:  BTFSC  F7F.1
186C:  BRA    186A
186E:  BCF    F7F.2
1870:  MOVF   00,W
1872:  IORWF  FF2,F
1874:  MOVLB  0
....................         } 
....................         //2minuty 
....................          if (c=='2'){ 
1876:  MOVF   2F,W
1878:  SUBLW  32
187A:  BNZ   18AA
....................                  write_eeprom(EEPROM_SIRENE_DELAY,2); 
187C:  MOVF   FF2,W
187E:  MOVWF  00
1880:  BCF    FF2.7
1882:  CLRF   F75
1884:  MOVLW  20
1886:  MOVWF  F74
1888:  MOVLW  02
188A:  MOVWF  F73
188C:  BCF    F7F.6
188E:  BCF    F7F.7
1890:  BSF    F7F.2
1892:  MOVLB  F
1894:  MOVLW  55
1896:  MOVWF  F7E
1898:  MOVLW  AA
189A:  MOVWF  F7E
189C:  BSF    F7F.1
189E:  BTFSC  F7F.1
18A0:  BRA    189E
18A2:  BCF    F7F.2
18A4:  MOVF   00,W
18A6:  IORWF  FF2,F
18A8:  MOVLB  0
....................          } 
....................          //5minut 
....................           if (c=='3'){ 
18AA:  MOVF   2F,W
18AC:  SUBLW  33
18AE:  BNZ   18DC
....................                  write_eeprom(EEPROM_SIRENE_DELAY,5); 
18B0:  MOVF   FF2,W
18B2:  MOVWF  00
18B4:  BCF    FF2.7
18B6:  CLRF   F75
18B8:  MOVLW  20
18BA:  MOVWF  F74
18BC:  MOVLW  05
18BE:  MOVWF  F73
18C0:  BCF    F7F.6
18C2:  BCF    F7F.7
18C4:  BSF    F7F.2
18C6:  MOVLB  F
18C8:  MOVLW  55
18CA:  MOVWF  F7E
18CC:  MOVLW  AA
18CE:  MOVWF  F7E
18D0:  BSF    F7F.1
18D2:  BTFSC  F7F.1
18D4:  BRA    18D2
18D6:  BCF    F7F.2
18D8:  MOVF   00,W
18DA:  IORWF  FF2,F
18DC:  MOVLB  0
....................           } 
18DE:  GOTO   28FC (RETURN)
.................... } 
....................  
.................... void alarm(int8 &line=0){ 
....................         state = st_alarm; 
*
276A:  MOVLW  02
276C:  MOVWF  07
*
2C7E:  MOVLW  02
2C80:  MOVWF  07
....................         printf("ALARM on line %d\n",line); 
*
276E:  MOVLW  98
2770:  MOVWF  FF6
2772:  MOVLW  00
2774:  MOVWF  FF7
2776:  MOVLW  0E
2778:  MOVWF  38
277A:  CALL   0BF4
277E:  MOVFF  2D,38
2782:  MOVLW  18
2784:  MOVWF  39
2786:  CALL   0DF8
278A:  MOVLW  0A
278C:  BTFSS  F9E.4
278E:  BRA    278C
2790:  MOVWF  FAD
*
2C82:  MOVLW  98
2C84:  MOVWF  FF6
2C86:  MOVLW  00
2C88:  MOVWF  FF7
2C8A:  MOVLW  0E
2C8C:  MOVWF  38
2C8E:  CALL   0BF4
2C92:  CLRF   38
2C94:  MOVLW  18
2C96:  MOVWF  39
2C98:  CALL   0DF8
2C9C:  MOVLW  0A
2C9E:  BTFSS  F9E.4
2CA0:  BRA    2C9E
2CA2:  MOVWF  FAD
.................... } 
....................  
.................... void sirene_on(){ 
....................         output_high(SIR); 
*
0C14:  BCF    F94.0
0C16:  BSF    F8B.0
....................         wassec=0; 
0C18:  CLRF   29
....................         sirene_timer=0; 
0C1A:  CLRF   2A
....................         read_time(); 
0C1C:  RCALL  0ADE
....................         printf("%02d:%02d:%02d Sirene ON\n", hour,min,sec); 
0C1E:  MOVFF  28,30
0C22:  MOVLW  01
0C24:  MOVWF  31
0C26:  RCALL  0B42
0C28:  MOVLW  3A
0C2A:  BTFSS  F9E.4
0C2C:  BRA    0C2A
0C2E:  MOVWF  FAD
0C30:  MOVFF  27,30
0C34:  MOVLW  01
0C36:  MOVWF  31
0C38:  RCALL  0B42
0C3A:  MOVLW  3A
0C3C:  BTFSS  F9E.4
0C3E:  BRA    0C3C
0C40:  MOVWF  FAD
0C42:  MOVFF  26,30
0C46:  MOVLW  01
0C48:  MOVWF  31
0C4A:  RCALL  0B42
0C4C:  MOVLW  B8
0C4E:  MOVWF  FF6
0C50:  MOVLW  00
0C52:  MOVWF  FF7
0C54:  MOVLW  0B
0C56:  MOVWF  38
0C58:  RCALL  0BF4
0C5A:  RETURN 0
.................... } 
....................  
.................... void sirene_off(){ 
....................         output_low(SIR); 
*
0F7A:  BCF    F94.0
0F7C:  BCF    F8B.0
....................    read_time(); 
0F7E:  RCALL  0ADE
....................         printf("%02d:%02d:%02d Sirene OFF\n", hour,min,sec); 
0F80:  MOVFF  28,30
0F84:  MOVLW  01
0F86:  MOVWF  31
0F88:  RCALL  0B42
0F8A:  MOVLW  3A
0F8C:  BTFSS  F9E.4
0F8E:  BRA    0F8C
0F90:  MOVWF  FAD
0F92:  MOVFF  27,30
0F96:  MOVLW  01
0F98:  MOVWF  31
0F9A:  RCALL  0B42
0F9C:  MOVLW  3A
0F9E:  BTFSS  F9E.4
0FA0:  BRA    0F9E
0FA2:  MOVWF  FAD
0FA4:  MOVFF  26,30
0FA8:  MOVLW  01
0FAA:  MOVWF  31
0FAC:  RCALL  0B42
0FAE:  MOVLW  D2
0FB0:  MOVWF  FF6
0FB2:  MOVLW  00
0FB4:  MOVWF  FF7
0FB6:  MOVLW  0C
0FB8:  MOVWF  38
0FBA:  RCALL  0BF4
0FBC:  RETURN 0
.................... } 
....................  
....................  
.................... void sirene_delay(){ 
....................    //jesli syrena wyje wystarczajaco dlugo to wylaczamy i status post alarm 
....................    if((sirene_timer/60) == read_eeprom(EEPROM_SIRENE_DELAY)){ 
0FBE:  MOVFF  2A,3E
0FC2:  MOVLW  3C
0FC4:  MOVWF  3F
0FC6:  RCALL  0B1A
0FC8:  MOVFF  01,2F
0FCC:  MOVFF  FF2,30
0FD0:  BCF    FF2.7
0FD2:  CLRF   F75
0FD4:  MOVLW  20
0FD6:  MOVWF  F74
0FD8:  BCF    F7F.6
0FDA:  BCF    F7F.7
0FDC:  BSF    F7F.0
0FDE:  MOVF   F73,W
0FE0:  BTFSC  30.7
0FE2:  BSF    FF2.7
0FE4:  SUBWF  2F,W
0FE6:  BNZ   0FF2
....................        sirene_off(); 
0FE8:  RCALL  0F7A
....................        state = st_postalarm; 
0FEA:  MOVLW  03
0FEC:  MOVWF  07
....................                  sirene_timer=sirene_timer+60; 
0FEE:  MOVLW  3C
0FF0:  ADDWF  2A,F
....................    } 
....................    //syrena jeszcze powinna wyc 
....................    if((sirene_timer/60) < read_eeprom(EEPROM_SIRENE_DELAY)){ 
0FF2:  MOVFF  2A,3E
0FF6:  MOVLW  3C
0FF8:  MOVWF  3F
0FFA:  RCALL  0B1A
0FFC:  MOVFF  01,2F
1000:  MOVFF  FF2,30
1004:  BCF    FF2.7
1006:  CLRF   F75
1008:  MOVLW  20
100A:  MOVWF  F74
100C:  BCF    F7F.6
100E:  BCF    F7F.7
1010:  BSF    F7F.0
1012:  MOVF   F73,W
1014:  BTFSC  30.7
1016:  BSF    FF2.7
1018:  SUBWF  2F,W
101A:  BC    103A
....................       //teraz sprawdzamy czas 
....................       delay_ms(800); 
101C:  MOVLW  04
101E:  MOVWF  2F
1020:  MOVLW  C8
1022:  MOVWF  30
1024:  CALL   0628
1028:  DECFSZ 2F,F
102A:  BRA    1020
....................       read_time(); 
102C:  RCALL  0ADE
....................            //printf("%02d:%02d:%02d\n", hour,min,sec); 
....................       //jesli uplynela przynajmniej minuta 
....................            if (wassec!=sec){ 
102E:  MOVF   26,W
1030:  SUBWF  29,W
1032:  BZ    103A
....................          wassec = sec; 
1034:  MOVFF  26,29
....................          sirene_timer++; 
1038:  INCF   2A,F
....................          //printf("Sirene %d min is running\n",(sirene_timer/60)); 
....................       } 
....................         } 
103A:  GOTO   2718 (RETURN)
....................     
.................... } 
....................  
.................... #include "lines.c" 
....................  
.................... ///------------LINIE ALARMU---------------- 
.................... //sprawdzanie linii alarmu, zwrot id naruszonej linii jesli jest wlaczona 
.................... unsigned char watchlines(){ 
....................          if ((input(L1) != DEF_LINE_STATE) && (read_eeprom(EEPROM_LINE1) == 1)){ 
*
1106:  BSF    F92.0
1108:  BTFSS  F80.0
110A:  BRA    112C
110C:  MOVFF  FF2,30
1110:  BCF    FF2.7
1112:  CLRF   F75
1114:  CLRF   F74
1116:  BCF    F7F.6
1118:  BCF    F7F.7
111A:  BSF    F7F.0
111C:  MOVF   F73,W
111E:  BTFSC  30.7
1120:  BSF    FF2.7
1122:  SUBLW  01
1124:  BNZ   112C
....................                 return 1; 
1126:  MOVLW  01
1128:  MOVWF  01
112A:  BRA    11A8
....................           }          
....................           if ((input(L2) != DEF_LINE_STATE) && (read_eeprom(EEPROM_LINE2) == 1)){ 
112C:  BSF    F92.1
112E:  BTFSS  F80.1
1130:  BRA    1154
1132:  MOVFF  FF2,30
1136:  BCF    FF2.7
1138:  CLRF   F75
113A:  MOVLW  01
113C:  MOVWF  F74
113E:  BCF    F7F.6
1140:  BCF    F7F.7
1142:  BSF    F7F.0
1144:  MOVF   F73,W
1146:  BTFSC  30.7
1148:  BSF    FF2.7
114A:  SUBLW  01
114C:  BNZ   1154
....................                 return 2; 
114E:  MOVLW  02
1150:  MOVWF  01
1152:  BRA    11A8
....................           } 
....................           if ((input(L3) != DEF_LINE_STATE) && (read_eeprom(EEPROM_LINE3) == 1)){ 
1154:  BSF    F92.2
1156:  BTFSS  F80.2
1158:  BRA    117C
115A:  MOVFF  FF2,30
115E:  BCF    FF2.7
1160:  CLRF   F75
1162:  MOVLW  02
1164:  MOVWF  F74
1166:  BCF    F7F.6
1168:  BCF    F7F.7
116A:  BSF    F7F.0
116C:  MOVF   F73,W
116E:  BTFSC  30.7
1170:  BSF    FF2.7
1172:  SUBLW  01
1174:  BNZ   117C
....................                 return 3; 
1176:  MOVLW  03
1178:  MOVWF  01
117A:  BRA    11A8
....................           } 
....................           if ((input(L4) != DEF_LINE_STATE) && (read_eeprom(EEPROM_LINE4) == 1)){ 
117C:  BSF    F92.3
117E:  BTFSS  F80.3
1180:  BRA    11A4
1182:  MOVFF  FF2,30
1186:  BCF    FF2.7
1188:  CLRF   F75
118A:  MOVLW  03
118C:  MOVWF  F74
118E:  BCF    F7F.6
1190:  BCF    F7F.7
1192:  BSF    F7F.0
1194:  MOVF   F73,W
1196:  BTFSC  30.7
1198:  BSF    FF2.7
119A:  SUBLW  01
119C:  BNZ   11A4
....................                 return 4; 
119E:  MOVLW  04
11A0:  MOVWF  01
11A2:  BRA    11A8
....................           } 
....................           return 0; 
11A4:  MOVLW  00
11A6:  MOVWF  01
11A8:  RETURN 0
.................... } 
....................  
.................... //pobranie czasu odczekiwania po wywolaniu z danej linii 1-4 natomiast 5to CAN 
.................... unsigned char line_wait(int8 line){ 
11AA:  CLRF   30
.................... 	  //domyslnie zero odczekiwania 
.................... 	  int8 wait=0; 
.................... 	  //sprawdzenie ile ma odczekac po wywolaniu z danej linii 
.................... 	  switch(line){ 
11AC:  MOVLW  01
11AE:  SUBWF  2F,W
11B0:  ADDLW  FB
11B2:  BC    1244
11B4:  ADDLW  05
11B6:  GOTO   124A
.................... 		 
.................... 		case 1:     
.................... 			wait=read_eeprom(EEPROM_LINE1_DELAY); 
11BA:  MOVFF  FF2,31
11BE:  BCF    FF2.7
11C0:  CLRF   F75
11C2:  MOVLW  05
11C4:  MOVWF  F74
11C6:  BCF    F7F.6
11C8:  BCF    F7F.7
11CA:  BSF    F7F.0
11CC:  MOVF   F73,W
11CE:  BTFSC  31.7
11D0:  BSF    FF2.7
11D2:  MOVWF  30
.................... 			break; 
11D4:  BRA    1244
....................  
.................... 		case 2:     
.................... 			wait=read_eeprom(EEPROM_LINE2_DELAY); 
11D6:  MOVFF  FF2,31
11DA:  BCF    FF2.7
11DC:  CLRF   F75
11DE:  MOVLW  06
11E0:  MOVWF  F74
11E2:  BCF    F7F.6
11E4:  BCF    F7F.7
11E6:  BSF    F7F.0
11E8:  MOVF   F73,W
11EA:  BTFSC  31.7
11EC:  BSF    FF2.7
11EE:  MOVWF  30
.................... 			break; 
11F0:  BRA    1244
....................  
....................  
.................... 		case 3:     
.................... 			wait=read_eeprom(EEPROM_LINE3_DELAY); 
11F2:  MOVFF  FF2,31
11F6:  BCF    FF2.7
11F8:  CLRF   F75
11FA:  MOVLW  07
11FC:  MOVWF  F74
11FE:  BCF    F7F.6
1200:  BCF    F7F.7
1202:  BSF    F7F.0
1204:  MOVF   F73,W
1206:  BTFSC  31.7
1208:  BSF    FF2.7
120A:  MOVWF  30
.................... 			break; 
120C:  BRA    1244
....................  
....................  
.................... 		case 4:     
.................... 			wait=read_eeprom(EEPROM_LINE4_DELAY); 
120E:  MOVFF  FF2,31
1212:  BCF    FF2.7
1214:  CLRF   F75
1216:  MOVLW  08
1218:  MOVWF  F74
121A:  BCF    F7F.6
121C:  BCF    F7F.7
121E:  BSF    F7F.0
1220:  MOVF   F73,W
1222:  BTFSC  31.7
1224:  BSF    FF2.7
1226:  MOVWF  30
.................... 			break; 
1228:  BRA    1244
.................... 		//odczekanie po wywolaniu z can 
.................... 		case 5:     
.................... 			wait=read_eeprom(EEPROM_LINECAN_DELAY); 
122A:  MOVFF  FF2,31
122E:  BCF    FF2.7
1230:  CLRF   F75
1232:  MOVLW  09
1234:  MOVWF  F74
1236:  BCF    F7F.6
1238:  BCF    F7F.7
123A:  BSF    F7F.0
123C:  MOVF   F73,W
123E:  BTFSC  31.7
1240:  BSF    FF2.7
1242:  MOVWF  30
.................... 			break; 
....................  
....................  
....................  
....................           } 
....................           return wait; 
1244:  MOVFF  30,01
1248:  RETURN 0
.................... } 
....................  
.................... void lines_monitor(){ 
.................... 	do{ 
.................... 	    if (input(L1)){ printf("1");}else{ printf("0");} 
*
176A:  BSF    F92.0
176C:  BTFSS  F80.0
176E:  BRA    177A
1770:  MOVLW  31
1772:  BTFSS  F9E.4
1774:  BRA    1772
1776:  MOVWF  FAD
1778:  BRA    1782
177A:  MOVLW  30
177C:  BTFSS  F9E.4
177E:  BRA    177C
1780:  MOVWF  FAD
.................... 	    if (input(L2)){ printf("1");}else{ printf("0");} 
1782:  BSF    F92.1
1784:  BTFSS  F80.1
1786:  BRA    1792
1788:  MOVLW  31
178A:  BTFSS  F9E.4
178C:  BRA    178A
178E:  MOVWF  FAD
1790:  BRA    179A
1792:  MOVLW  30
1794:  BTFSS  F9E.4
1796:  BRA    1794
1798:  MOVWF  FAD
.................... 	    if (input(L3)){ printf("1");}else{ printf("0");} 
179A:  BSF    F92.2
179C:  BTFSS  F80.2
179E:  BRA    17AA
17A0:  MOVLW  31
17A2:  BTFSS  F9E.4
17A4:  BRA    17A2
17A6:  MOVWF  FAD
17A8:  BRA    17B2
17AA:  MOVLW  30
17AC:  BTFSS  F9E.4
17AE:  BRA    17AC
17B0:  MOVWF  FAD
.................... 	    if (input(L4)){ printf("1");}else{ printf("0");} 
17B2:  BSF    F92.3
17B4:  BTFSS  F80.3
17B6:  BRA    17C2
17B8:  MOVLW  31
17BA:  BTFSS  F9E.4
17BC:  BRA    17BA
17BE:  MOVWF  FAD
17C0:  BRA    17CA
17C2:  MOVLW  30
17C4:  BTFSS  F9E.4
17C6:  BRA    17C4
17C8:  MOVWF  FAD
.................... 	    printf("\n"); 
17CA:  MOVLW  0A
17CC:  BTFSS  F9E.4
17CE:  BRA    17CC
17D0:  MOVWF  FAD
.................... 	    delay_ms(800); 
17D2:  MOVLW  04
17D4:  MOVWF  2F
17D6:  MOVLW  C8
17D8:  MOVWF  30
17DA:  CALL   0628
17DE:  DECFSZ 2F,F
17E0:  BRA    17D6
.................... 	}while(!kbhit()); 
17E2:  BTFSS  F9E.5
17E4:  BRA    176A
17E6:  GOTO   28FC (RETURN)
.................... } 
....................  
.................... //sprawdzenie do jakich linii podlaczone sa czujki i ich wlaczenie 
.................... void initlines(){ 
....................           //wylaczenie wszystkich linii 
....................           write_eeprom(EEPROM_LINE1,0); 
*
1284:  MOVF   FF2,W
1286:  MOVWF  00
1288:  BCF    FF2.7
128A:  CLRF   F75
128C:  CLRF   F74
128E:  CLRF   F73
1290:  BCF    F7F.6
1292:  BCF    F7F.7
1294:  BSF    F7F.2
1296:  MOVLB  F
1298:  MOVLW  55
129A:  MOVWF  F7E
129C:  MOVLW  AA
129E:  MOVWF  F7E
12A0:  BSF    F7F.1
12A2:  BTFSC  F7F.1
12A4:  BRA    12A2
12A6:  BCF    F7F.2
12A8:  MOVF   00,W
12AA:  IORWF  FF2,F
....................           write_eeprom(EEPROM_LINE2,0); 
12AC:  MOVFF  FF2,00
12B0:  BCF    FF2.7
12B2:  CLRF   F75
12B4:  MOVLW  01
12B6:  MOVWF  F74
12B8:  CLRF   F73
12BA:  BCF    F7F.6
12BC:  BCF    F7F.7
12BE:  BSF    F7F.2
12C0:  MOVLW  55
12C2:  MOVWF  F7E
12C4:  MOVLW  AA
12C6:  MOVWF  F7E
12C8:  BSF    F7F.1
12CA:  BTFSC  F7F.1
12CC:  BRA    12CA
12CE:  BCF    F7F.2
12D0:  MOVF   00,W
12D2:  IORWF  FF2,F
....................           write_eeprom(EEPROM_LINE3,0); 
12D4:  MOVFF  FF2,00
12D8:  BCF    FF2.7
12DA:  CLRF   F75
12DC:  MOVLW  02
12DE:  MOVWF  F74
12E0:  CLRF   F73
12E2:  BCF    F7F.6
12E4:  BCF    F7F.7
12E6:  BSF    F7F.2
12E8:  MOVLW  55
12EA:  MOVWF  F7E
12EC:  MOVLW  AA
12EE:  MOVWF  F7E
12F0:  BSF    F7F.1
12F2:  BTFSC  F7F.1
12F4:  BRA    12F2
12F6:  BCF    F7F.2
12F8:  MOVF   00,W
12FA:  IORWF  FF2,F
....................           write_eeprom(EEPROM_LINE4,0); 
12FC:  MOVFF  FF2,00
1300:  BCF    FF2.7
1302:  CLRF   F75
1304:  MOVLW  03
1306:  MOVWF  F74
1308:  CLRF   F73
130A:  BCF    F7F.6
130C:  BCF    F7F.7
130E:  BSF    F7F.2
1310:  MOVLW  55
1312:  MOVWF  F7E
1314:  MOVLW  AA
1316:  MOVWF  F7E
1318:  BSF    F7F.1
131A:  BTFSC  F7F.1
131C:  BRA    131A
131E:  BCF    F7F.2
1320:  MOVF   00,W
1322:  IORWF  FF2,F
....................            
....................           //jesli jest podpieta czujka wlacz linie1 
....................           if (input(L1) != DEF_LINE_STATE){ 
1324:  BSF    F92.0
1326:  BTFSS  F80.0
1328:  BRA    1364
....................                 write_eeprom(EEPROM_LINE1,1); 
132A:  MOVFF  FF2,00
132E:  BCF    FF2.7
1330:  CLRF   F75
1332:  CLRF   F74
1334:  MOVLW  01
1336:  MOVWF  F73
1338:  BCF    F7F.6
133A:  BCF    F7F.7
133C:  BSF    F7F.2
133E:  MOVLW  55
1340:  MOVWF  F7E
1342:  MOVLW  AA
1344:  MOVWF  F7E
1346:  BSF    F7F.1
1348:  BTFSC  F7F.1
134A:  BRA    1348
134C:  BCF    F7F.2
134E:  MOVF   00,W
1350:  IORWF  FF2,F
....................                 printf("Line1 ON\n"); 
1352:  MOVLW  E0
1354:  MOVWF  FF6
1356:  MOVLW  00
1358:  MOVWF  FF7
135A:  MOVLB  0
135C:  CALL   064E
....................           }     
1360:  BRA    1398
1362:  MOVLB  F
....................           else{ 
....................                 write_eeprom(EEPROM_LINE1,0); 
1364:  MOVFF  FF2,00
1368:  BCF    FF2.7
136A:  CLRF   F75
136C:  CLRF   F74
136E:  CLRF   F73
1370:  BCF    F7F.6
1372:  BCF    F7F.7
1374:  BSF    F7F.2
1376:  MOVLW  55
1378:  MOVWF  F7E
137A:  MOVLW  AA
137C:  MOVWF  F7E
137E:  BSF    F7F.1
1380:  BTFSC  F7F.1
1382:  BRA    1380
1384:  BCF    F7F.2
1386:  MOVF   00,W
1388:  IORWF  FF2,F
....................                 printf("Line1 OFF\n"); 
138A:  MOVLW  EA
138C:  MOVWF  FF6
138E:  MOVLW  00
1390:  MOVWF  FF7
1392:  MOVLB  0
1394:  CALL   064E
....................           }      
....................           //jesli jest podpieta czujka wlacz linie2 
....................           if (input(L2) != DEF_LINE_STATE){ 
1398:  BSF    F92.1
139A:  BTFSS  F80.1
139C:  BRA    13D8
....................                 write_eeprom(EEPROM_LINE2,1); 
139E:  MOVF   FF2,W
13A0:  MOVWF  00
13A2:  BCF    FF2.7
13A4:  CLRF   F75
13A6:  MOVLW  01
13A8:  MOVWF  F74
13AA:  MOVWF  F73
13AC:  BCF    F7F.6
13AE:  BCF    F7F.7
13B0:  BSF    F7F.2
13B2:  MOVLB  F
13B4:  MOVLW  55
13B6:  MOVWF  F7E
13B8:  MOVLW  AA
13BA:  MOVWF  F7E
13BC:  BSF    F7F.1
13BE:  BTFSC  F7F.1
13C0:  BRA    13BE
13C2:  BCF    F7F.2
13C4:  MOVF   00,W
13C6:  IORWF  FF2,F
....................                 printf("Line2 ON\n"); 
13C8:  MOVLW  F6
13CA:  MOVWF  FF6
13CC:  MOVLW  00
13CE:  MOVWF  FF7
13D0:  MOVLB  0
13D2:  CALL   064E
....................           } 
13D6:  BRA    1410
....................           else{ 
....................                 write_eeprom(EEPROM_LINE2,0); 
13D8:  MOVF   FF2,W
13DA:  MOVWF  00
13DC:  BCF    FF2.7
13DE:  CLRF   F75
13E0:  MOVLW  01
13E2:  MOVWF  F74
13E4:  CLRF   F73
13E6:  BCF    F7F.6
13E8:  BCF    F7F.7
13EA:  BSF    F7F.2
13EC:  MOVLB  F
13EE:  MOVLW  55
13F0:  MOVWF  F7E
13F2:  MOVLW  AA
13F4:  MOVWF  F7E
13F6:  BSF    F7F.1
13F8:  BTFSC  F7F.1
13FA:  BRA    13F8
13FC:  BCF    F7F.2
13FE:  MOVF   00,W
1400:  IORWF  FF2,F
....................                 printf("Line2 OFF\n"); 
1402:  MOVLW  00
1404:  MOVWF  FF6
1406:  MOVLW  01
1408:  MOVWF  FF7
140A:  MOVLB  0
140C:  CALL   064E
....................           }      
....................           //jesli jest podpieta czujka wlacz linie3 
....................           if (input(L3) != DEF_LINE_STATE){ 
1410:  BSF    F92.2
1412:  BTFSS  F80.2
1414:  BRA    1452
....................                 write_eeprom(EEPROM_LINE3,1); 
1416:  MOVF   FF2,W
1418:  MOVWF  00
141A:  BCF    FF2.7
141C:  CLRF   F75
141E:  MOVLW  02
1420:  MOVWF  F74
1422:  MOVLW  01
1424:  MOVWF  F73
1426:  BCF    F7F.6
1428:  BCF    F7F.7
142A:  BSF    F7F.2
142C:  MOVLB  F
142E:  MOVLW  55
1430:  MOVWF  F7E
1432:  MOVLW  AA
1434:  MOVWF  F7E
1436:  BSF    F7F.1
1438:  BTFSC  F7F.1
143A:  BRA    1438
143C:  BCF    F7F.2
143E:  MOVF   00,W
1440:  IORWF  FF2,F
....................                 printf("Line3 ON\n"); 
1442:  MOVLW  0C
1444:  MOVWF  FF6
1446:  MOVLW  01
1448:  MOVWF  FF7
144A:  MOVLB  0
144C:  CALL   064E
....................           } 
1450:  BRA    148A
....................           else{ 
....................                 write_eeprom(EEPROM_LINE3,0); 
1452:  MOVF   FF2,W
1454:  MOVWF  00
1456:  BCF    FF2.7
1458:  CLRF   F75
145A:  MOVLW  02
145C:  MOVWF  F74
145E:  CLRF   F73
1460:  BCF    F7F.6
1462:  BCF    F7F.7
1464:  BSF    F7F.2
1466:  MOVLB  F
1468:  MOVLW  55
146A:  MOVWF  F7E
146C:  MOVLW  AA
146E:  MOVWF  F7E
1470:  BSF    F7F.1
1472:  BTFSC  F7F.1
1474:  BRA    1472
1476:  BCF    F7F.2
1478:  MOVF   00,W
147A:  IORWF  FF2,F
....................                 printf("Line3 OFF\n"); 
147C:  MOVLW  16
147E:  MOVWF  FF6
1480:  MOVLW  01
1482:  MOVWF  FF7
1484:  MOVLB  0
1486:  CALL   064E
....................           }                
....................           //jesli jest podpieta czujka wlacz linie4 
....................           if (input(L4) != DEF_LINE_STATE){ 
148A:  BSF    F92.3
148C:  BTFSS  F80.3
148E:  BRA    14CC
....................                 write_eeprom(EEPROM_LINE4,1); 
1490:  MOVF   FF2,W
1492:  MOVWF  00
1494:  BCF    FF2.7
1496:  CLRF   F75
1498:  MOVLW  03
149A:  MOVWF  F74
149C:  MOVLW  01
149E:  MOVWF  F73
14A0:  BCF    F7F.6
14A2:  BCF    F7F.7
14A4:  BSF    F7F.2
14A6:  MOVLB  F
14A8:  MOVLW  55
14AA:  MOVWF  F7E
14AC:  MOVLW  AA
14AE:  MOVWF  F7E
14B0:  BSF    F7F.1
14B2:  BTFSC  F7F.1
14B4:  BRA    14B2
14B6:  BCF    F7F.2
14B8:  MOVF   00,W
14BA:  IORWF  FF2,F
....................                 printf("Line4 ON\n"); 
14BC:  MOVLW  22
14BE:  MOVWF  FF6
14C0:  MOVLW  01
14C2:  MOVWF  FF7
14C4:  MOVLB  0
14C6:  CALL   064E
....................           } 
14CA:  BRA    1504
....................           else{ 
....................                 write_eeprom(EEPROM_LINE4,0); 
14CC:  MOVF   FF2,W
14CE:  MOVWF  00
14D0:  BCF    FF2.7
14D2:  CLRF   F75
14D4:  MOVLW  03
14D6:  MOVWF  F74
14D8:  CLRF   F73
14DA:  BCF    F7F.6
14DC:  BCF    F7F.7
14DE:  BSF    F7F.2
14E0:  MOVLB  F
14E2:  MOVLW  55
14E4:  MOVWF  F7E
14E6:  MOVLW  AA
14E8:  MOVWF  F7E
14EA:  BSF    F7F.1
14EC:  BTFSC  F7F.1
14EE:  BRA    14EC
14F0:  BCF    F7F.2
14F2:  MOVF   00,W
14F4:  IORWF  FF2,F
....................                 printf("Line4 OFF\n"); 
14F6:  MOVLW  2C
14F8:  MOVWF  FF6
14FA:  MOVLW  01
14FC:  MOVWF  FF7
14FE:  MOVLB  0
1500:  CALL   064E
....................           }      
1504:  GOTO   28FC (RETURN)
.................... } 
....................  
....................  
.................... ///------------config linii alarmu------------------ 
.................... void lines_config(){ 
....................         printf("1 - Line ON/OFF\n"); 
1508:  MOVLW  38
150A:  MOVWF  FF6
150C:  MOVLW  01
150E:  MOVWF  FF7
1510:  CALL   064E
....................         printf("2 - Line delay\n"); 
1514:  MOVLW  4A
1516:  MOVWF  FF6
1518:  MOVLW  01
151A:  MOVWF  FF7
151C:  CALL   064E
....................         char c=getc(); 
1520:  RCALL  126E
1522:  MOVFF  01,2F
....................         switch (c){ 
1526:  MOVF   2F,W
1528:  XORLW  31
152A:  BZ    1534
152C:  XORLW  03
152E:  BTFSC  FD8.2
1530:  BRA    163C
1532:  BRA    1766
....................                    //wlaczenie wylaczenie linii 
....................                    case '1':  
....................                         printf(">Line ON/OFF\n"); 
1534:  MOVLW  5A
1536:  MOVWF  FF6
1538:  MOVLW  01
153A:  MOVWF  FF7
153C:  CALL   064E
....................          		int8 xx; 
....................                         for(xx=0;xx<5;xx++){ 
1540:  CLRF   30
1542:  MOVF   30,W
1544:  SUBLW  04
1546:  BTFSS  FD8.0
1548:  BRA    163A
....................                                 printf("Line %d is set to ",xx); 
154A:  MOVLW  68
154C:  MOVWF  FF6
154E:  MOVLW  01
1550:  MOVWF  FF7
1552:  MOVLW  05
1554:  MOVWF  38
1556:  CALL   0BF4
155A:  MOVFF  30,38
155E:  MOVLW  18
1560:  MOVWF  39
1562:  RCALL  0DF8
1564:  MOVLW  6F
1566:  MOVWF  FF6
1568:  MOVLW  01
156A:  MOVWF  FF7
156C:  MOVLW  0B
156E:  MOVWF  38
1570:  CALL   0BF4
....................                                 if (read_eeprom(xx) == 1){ 
1574:  MOVFF  FF2,32
1578:  BCF    FF2.7
157A:  CLRF   F75
157C:  MOVFF  30,F74
1580:  BCF    F7F.6
1582:  BCF    F7F.7
1584:  BSF    F7F.0
1586:  MOVF   F73,W
1588:  BTFSC  32.7
158A:  BSF    FF2.7
158C:  SUBLW  01
158E:  BNZ   159E
....................                                         printf("ON\n"); 
1590:  MOVLW  7C
1592:  MOVWF  FF6
1594:  MOVLW  01
1596:  MOVWF  FF7
1598:  CALL   064E
....................                                 } 
159C:  BRA    15AA
....................                                 else { 
....................                                         printf("OFF\n"); 
159E:  MOVLW  80
15A0:  MOVWF  FF6
15A2:  MOVLW  01
15A4:  MOVWF  FF7
15A6:  CALL   064E
....................                                 } 
....................                                 printf("Set to 1-ON 2-OFF\n"); 
15AA:  MOVLW  86
15AC:  MOVWF  FF6
15AE:  MOVLW  01
15B0:  MOVWF  FF7
15B2:  CALL   064E
....................                                 c = getc(); 
15B6:  RCALL  126E
15B8:  MOVFF  01,2F
....................                                 if (c=='1'){ 
15BC:  MOVF   2F,W
15BE:  SUBLW  31
15C0:  BNZ   15FE
....................                                         write_eeprom(xx,1); 
15C2:  MOVF   FF2,W
15C4:  MOVWF  00
15C6:  BCF    FF2.7
15C8:  CLRF   F75
15CA:  MOVFF  30,F74
15CE:  MOVLW  01
15D0:  MOVWF  F73
15D2:  BCF    F7F.6
15D4:  BCF    F7F.7
15D6:  BSF    F7F.2
15D8:  MOVLB  F
15DA:  MOVLW  55
15DC:  MOVWF  F7E
15DE:  MOVLW  AA
15E0:  MOVWF  F7E
15E2:  BSF    F7F.1
15E4:  BTFSC  F7F.1
15E6:  BRA    15E4
15E8:  BCF    F7F.2
15EA:  MOVF   00,W
15EC:  IORWF  FF2,F
....................                                         printf("Set ON\n"); 
15EE:  MOVLW  9A
15F0:  MOVWF  FF6
15F2:  MOVLW  01
15F4:  MOVWF  FF7
15F6:  MOVLB  0
15F8:  CALL   064E
....................                                 } 
15FC:  BRA    1636
....................                                 else { 
....................                                         write_eeprom(xx,0); 
15FE:  MOVF   FF2,W
1600:  MOVWF  00
1602:  BCF    FF2.7
1604:  CLRF   F75
1606:  MOVFF  30,F74
160A:  CLRF   F73
160C:  BCF    F7F.6
160E:  BCF    F7F.7
1610:  BSF    F7F.2
1612:  MOVLB  F
1614:  MOVLW  55
1616:  MOVWF  F7E
1618:  MOVLW  AA
161A:  MOVWF  F7E
161C:  BSF    F7F.1
161E:  BTFSC  F7F.1
1620:  BRA    161E
1622:  BCF    F7F.2
1624:  MOVF   00,W
1626:  IORWF  FF2,F
....................                                         printf("Set OFF\n"); 
1628:  MOVLW  A2
162A:  MOVWF  FF6
162C:  MOVLW  01
162E:  MOVWF  FF7
1630:  MOVLB  0
1632:  CALL   064E
....................                                 } 
1636:  INCF   30,F
1638:  BRA    1542
....................                         } 
....................                         break; 
163A:  BRA    1766
....................                    //opoznienie linii 
....................                    case '2':  
....................                         printf(">Line delay\n"); 
163C:  MOVLW  AC
163E:  MOVWF  FF6
1640:  MOVLW  01
1642:  MOVWF  FF7
1644:  CALL   064E
....................                         for(int x=EEPROM_LINE1_DELAY;x<(EEPROM_LINE4_DELAY+1);x++){ 
1648:  MOVLW  05
164A:  MOVWF  31
164C:  MOVF   31,W
164E:  SUBLW  08
1650:  BTFSS  FD8.0
1652:  BRA    1766
....................                                 printf("Line %d delay %d sec \n",x,read_eeprom(x)); 
1654:  MOVFF  FF2,32
1658:  BCF    FF2.7
165A:  CLRF   F75
165C:  MOVFF  31,F74
1660:  BCF    F7F.6
1662:  BCF    F7F.7
1664:  BSF    F7F.0
1666:  MOVF   F73,W
1668:  BTFSC  32.7
166A:  BSF    FF2.7
166C:  MOVWF  33
166E:  MOVLW  BA
1670:  MOVWF  FF6
1672:  MOVLW  01
1674:  MOVWF  FF7
1676:  MOVLW  05
1678:  MOVWF  38
167A:  CALL   0BF4
167E:  MOVFF  31,38
1682:  MOVLW  18
1684:  MOVWF  39
1686:  CALL   0DF8
168A:  MOVLW  C1
168C:  MOVWF  FF6
168E:  MOVLW  01
1690:  MOVWF  FF7
1692:  MOVLW  07
1694:  MOVWF  38
1696:  CALL   0BF4
169A:  MOVFF  33,38
169E:  MOVLW  18
16A0:  MOVWF  39
16A2:  CALL   0DF8
16A6:  MOVLW  CA
16A8:  MOVWF  FF6
16AA:  MOVLW  01
16AC:  MOVWF  FF7
16AE:  MOVLW  06
16B0:  MOVWF  38
16B2:  CALL   0BF4
....................                                 printf("Set to 1-0sec 2-30sec 3-60sec\n"); 
16B6:  MOVLW  D2
16B8:  MOVWF  FF6
16BA:  MOVLW  01
16BC:  MOVWF  FF7
16BE:  CALL   064E
....................                                 c = getc(); 
16C2:  RCALL  126E
16C4:  MOVFF  01,2F
....................                                 //wlaczenie zaraz po naruszeniu  
....................                                 if (c=='1'){ 
16C8:  MOVF   2F,W
16CA:  SUBLW  31
16CC:  BNZ   16FA
....................                                         write_eeprom(x,0); 
16CE:  MOVF   FF2,W
16D0:  MOVWF  00
16D2:  BCF    FF2.7
16D4:  CLRF   F75
16D6:  MOVFF  31,F74
16DA:  CLRF   F73
16DC:  BCF    F7F.6
16DE:  BCF    F7F.7
16E0:  BSF    F7F.2
16E2:  MOVLB  F
16E4:  MOVLW  55
16E6:  MOVWF  F7E
16E8:  MOVLW  AA
16EA:  MOVWF  F7E
16EC:  BSF    F7F.1
16EE:  BTFSC  F7F.1
16F0:  BRA    16EE
16F2:  BCF    F7F.2
16F4:  MOVF   00,W
16F6:  IORWF  FF2,F
16F8:  MOVLB  0
....................                                 } 
....................                                 //30sec po naruszeniu 
....................                                 if (c=='2'){ 
16FA:  MOVF   2F,W
16FC:  SUBLW  32
16FE:  BNZ   172E
....................                                         write_eeprom(x,30); 
1700:  MOVF   FF2,W
1702:  MOVWF  00
1704:  BCF    FF2.7
1706:  CLRF   F75
1708:  MOVFF  31,F74
170C:  MOVLW  1E
170E:  MOVWF  F73
1710:  BCF    F7F.6
1712:  BCF    F7F.7
1714:  BSF    F7F.2
1716:  MOVLB  F
1718:  MOVLW  55
171A:  MOVWF  F7E
171C:  MOVLW  AA
171E:  MOVWF  F7E
1720:  BSF    F7F.1
1722:  BTFSC  F7F.1
1724:  BRA    1722
1726:  BCF    F7F.2
1728:  MOVF   00,W
172A:  IORWF  FF2,F
172C:  MOVLB  0
....................                                 } 
....................                                 //60sec po naruszeniu 
....................                                 if (c=='3'){ 
172E:  MOVF   2F,W
1730:  SUBLW  33
1732:  BNZ   1762
....................                                         write_eeprom(x,60); 
1734:  MOVF   FF2,W
1736:  MOVWF  00
1738:  BCF    FF2.7
173A:  CLRF   F75
173C:  MOVFF  31,F74
1740:  MOVLW  3C
1742:  MOVWF  F73
1744:  BCF    F7F.6
1746:  BCF    F7F.7
1748:  BSF    F7F.2
174A:  MOVLB  F
174C:  MOVLW  55
174E:  MOVWF  F7E
1750:  MOVLW  AA
1752:  MOVWF  F7E
1754:  BSF    F7F.1
1756:  BTFSC  F7F.1
1758:  BRA    1756
175A:  BCF    F7F.2
175C:  MOVF   00,W
175E:  IORWF  FF2,F
1760:  MOVLB  0
....................                                 } 
1762:  INCF   31,F
1764:  BRA    164C
....................                         }                         
....................                         break; 
....................         } 
1766:  GOTO   28FC (RETURN)
.................... } 
....................  
.................... #include "cards.c" 
....................  
.................... //-----konfiguracja kart--------------- 
.................... void cards_config(){ 
*
1AC2:  CLRF   2F
1AC4:  CLRF   30
....................         unsigned int8 readed=0; 
....................         unsigned int8 added=0; 
....................         printf("1 - list\n"); 
1AC6:  MOVLW  F2
1AC8:  MOVWF  FF6
1ACA:  MOVLW  01
1ACC:  MOVWF  FF7
1ACE:  CALL   064E
....................         printf("2 - add card\n"); 
1AD2:  MOVLW  FC
1AD4:  MOVWF  FF6
1AD6:  MOVLW  01
1AD8:  MOVWF  FF7
1ADA:  CALL   064E
....................         printf("3 - remove card\n"); 
1ADE:  MOVLW  0A
1AE0:  MOVWF  FF6
1AE2:  MOVLW  02
1AE4:  MOVWF  FF7
1AE6:  CALL   064E
....................         char c=getc(); 
1AEA:  CALL   126E
1AEE:  MOVFF  01,31
....................         switch (c){ 
1AF2:  MOVF   31,W
1AF4:  XORLW  31
1AF6:  BZ    1B04
1AF8:  XORLW  03
1AFA:  BZ    1B64
1AFC:  XORLW  01
1AFE:  BTFSC  FD8.2
1B00:  BRA    1F32
1B02:  BRA    2000
....................            //lista kart 
....................            case '1': 
....................                 for(int8 eeprom_address=EEPROM_CARD1;eeprom_address<EEPROM_CARD10+1;eeprom_address++){ 
1B04:  MOVLW  10
1B06:  MOVWF  32
1B08:  MOVF   32,W
1B0A:  SUBLW  19
1B0C:  BNC   1B62
....................                         printf("%d : %d\n",(eeprom_address-EEPROM_CARD1),read_eeprom(eeprom_address)); 
1B0E:  MOVLW  10
1B10:  SUBWF  32,W
1B12:  MOVWF  35
1B14:  MOVFF  FF2,36
1B18:  BCF    FF2.7
1B1A:  CLRF   F75
1B1C:  MOVFF  32,F74
1B20:  BCF    F7F.6
1B22:  BCF    F7F.7
1B24:  BSF    F7F.0
1B26:  MOVF   F73,W
1B28:  BTFSC  36.7
1B2A:  BSF    FF2.7
1B2C:  MOVWF  37
1B2E:  MOVFF  35,38
1B32:  MOVLW  18
1B34:  MOVWF  39
1B36:  CALL   0DF8
1B3A:  MOVLW  1E
1B3C:  MOVWF  FF6
1B3E:  MOVLW  02
1B40:  MOVWF  FF7
1B42:  MOVLW  03
1B44:  MOVWF  38
1B46:  CALL   0BF4
1B4A:  MOVFF  37,38
1B4E:  MOVLW  18
1B50:  MOVWF  39
1B52:  CALL   0DF8
1B56:  MOVLW  0A
1B58:  BTFSS  F9E.4
1B5A:  BRA    1B58
1B5C:  MOVWF  FAD
1B5E:  INCF   32,F
1B60:  BRA    1B08
....................                 } 
....................                 break; 
1B62:  BRA    2000
....................            //dodaj karte 
....................            case '2':  
....................                 printf("waiting for new card (or any key to abort)....\n"); 
1B64:  MOVLW  26
1B66:  MOVWF  FF6
1B68:  MOVLW  02
1B6A:  MOVWF  FF7
1B6C:  CALL   064E
....................                 while((readed != 1)&&(!kbhit())){ 
1B70:  DECFSZ 2F,W
1B72:  BRA    1B76
1B74:  BRA    1F30
1B76:  BTFSC  F9E.5
1B78:  BRA    1F30
....................                 //odebrano dane z can 
....................                 if(can_getd(rx_id, buffer, rx_len, rxstat))  
1B7A:  CLRF   36
1B7C:  MOVLW  16
1B7E:  MOVWF  35
*
1DEE:  MOVF   01,F
1DF0:  BTFSC  FD8.2
1DF2:  BRA    1F2C
....................                 {  
....................                    //dane dla tego urzadzenia 
....................                    if(rx_id == CAN_ALARM_ID){ 
1DF4:  MOVF   0D,W
1DF6:  SUBLW  14
1DF8:  BTFSS  FD8.2
1DFA:  BRA    1F2C
1DFC:  MOVF   0E,F
1DFE:  BTFSS  FD8.2
1E00:  BRA    1F2C
1E02:  MOVF   0F,F
1E04:  BTFSS  FD8.2
1E06:  BRA    1F2C
1E08:  MOVF   10,F
1E0A:  BTFSS  FD8.2
1E0C:  BRA    1F2C
....................                       //dane zawieraja crc karty 
....................                       if (buffer[0] == 'c'){ 
1E0E:  MOVF   16,W
1E10:  SUBLW  63
1E12:  BTFSS  FD8.2
1E14:  BRA    1F2C
.................... 		      //przelecenie po pamieci gdzie sa zapisane crc kart 
....................                       for(int8 eeprom_address=EEPROM_CARD1;eeprom_address<EEPROM_CARD10+1;eeprom_address++){ 
1E16:  MOVLW  10
1E18:  MOVWF  33
1E1A:  MOVF   33,W
1E1C:  SUBLW  19
1E1E:  BTFSS  FD8.0
1E20:  BRA    1F14
.................... 			  //jesli karta juz jest w pamieci to konczymy 
.................... 			  if (read_eeprom(eeprom_address)==buffer[1]){ 
1E22:  MOVFF  FF2,35
1E26:  BCF    FF2.7
1E28:  CLRF   F75
1E2A:  MOVFF  33,F74
1E2E:  BCF    F7F.6
1E30:  BCF    F7F.7
1E32:  BSF    F7F.0
1E34:  MOVF   F73,W
1E36:  BTFSC  35.7
1E38:  BSF    FF2.7
1E3A:  SUBWF  17,W
1E3C:  BNZ   1E54
.................... 				printf("Card was added here\n"); 
1E3E:  MOVLW  56
1E40:  MOVWF  FF6
1E42:  MOVLW  02
1E44:  MOVWF  FF7
1E46:  MOVLB  0
1E48:  CALL   064E
.................... 				added = 1; 
1E4C:  MOVLW  01
1E4E:  MOVWF  30
....................                                 break; 
1E50:  MOVLB  E
1E52:  BRA    1F14
.................... 			  } 
....................                           //pewnie karty niebylo w pamieci wiec dopisujemy 
....................                           if (read_eeprom(eeprom_address)==-1 || read_eeprom(eeprom_address)==0){ 
1E54:  MOVFF  FF2,35
1E58:  BCF    FF2.7
1E5A:  CLRF   F75
1E5C:  MOVFF  33,F74
1E60:  BCF    F7F.6
1E62:  BCF    F7F.7
1E64:  BSF    F7F.0
1E66:  MOVF   F73,W
1E68:  BTFSC  35.7
1E6A:  BSF    FF2.7
1E6C:  SUBLW  FF
1E6E:  BZ    1E8C
1E70:  MOVFF  FF2,36
1E74:  BCF    FF2.7
1E76:  CLRF   F75
1E78:  MOVFF  33,F74
1E7C:  BCF    F7F.6
1E7E:  BCF    F7F.7
1E80:  BSF    F7F.0
1E82:  MOVF   F73,W
1E84:  BTFSC  36.7
1E86:  BSF    FF2.7
1E88:  XORLW  00
1E8A:  BNZ   1F10
....................                                 write_eeprom(eeprom_address,buffer[1]); 
1E8C:  MOVF   FF2,W
1E8E:  MOVWF  00
1E90:  BCF    FF2.7
1E92:  CLRF   F75
1E94:  MOVFF  33,F74
1E98:  MOVFF  17,F73
1E9C:  BCF    F7F.6
1E9E:  BCF    F7F.7
1EA0:  BSF    F7F.2
1EA2:  MOVLB  F
1EA4:  MOVLW  55
1EA6:  MOVWF  F7E
1EA8:  MOVLW  AA
1EAA:  MOVWF  F7E
1EAC:  BSF    F7F.1
1EAE:  BTFSC  F7F.1
1EB0:  BRA    1EAE
1EB2:  BCF    F7F.2
1EB4:  MOVF   00,W
1EB6:  IORWF  FF2,F
....................                                 printf("Card %d added on %d place\n",buffer[1],(eeprom_address-EEPROM_CARD1)); 
1EB8:  MOVLW  10
1EBA:  SUBWF  33,W
1EBC:  MOVWF  35
1EBE:  MOVLW  6C
1EC0:  MOVWF  FF6
1EC2:  MOVLW  02
1EC4:  MOVWF  FF7
1EC6:  MOVLW  05
1EC8:  MOVWF  38
1ECA:  MOVLB  0
1ECC:  CALL   0BF4
1ED0:  MOVFF  17,38
1ED4:  MOVLW  18
1ED6:  MOVWF  39
1ED8:  CALL   0DF8
1EDC:  MOVLW  73
1EDE:  MOVWF  FF6
1EE0:  MOVLW  02
1EE2:  MOVWF  FF7
1EE4:  MOVLW  0A
1EE6:  MOVWF  38
1EE8:  CALL   0BF4
1EEC:  MOVFF  35,38
1EF0:  MOVLW  18
1EF2:  MOVWF  39
1EF4:  CALL   0DF8
1EF8:  MOVLW  7F
1EFA:  MOVWF  FF6
1EFC:  MOVLW  02
1EFE:  MOVWF  FF7
1F00:  MOVLW  07
1F02:  MOVWF  38
1F04:  CALL   0BF4
....................                                 added = 1; 
1F08:  MOVLW  01
1F0A:  MOVWF  30
....................                                 break; 
1F0C:  MOVLB  E
1F0E:  BRA    1F14
....................                           } 
1F10:  INCF   33,F
1F12:  BRA    1E1A
....................                       } 
.................... 		      //karta nie zostala dodana i skonczyl sie przelot po wolnej pamieci 
....................                       if (added == 0){ 
1F14:  MOVF   30,F
1F16:  BNZ   1F28
....................                         printf("Not empty space for new card\n"); 
1F18:  MOVLW  88
1F1A:  MOVWF  FF6
1F1C:  MOVLW  02
1F1E:  MOVWF  FF7
1F20:  MOVLB  0
1F22:  CALL   064E
1F26:  MOVLB  E
....................                       } 
....................                       readed = 1; 
1F28:  MOVLW  01
1F2A:  MOVWF  2F
....................                       } 
....................                    } 
....................                 } 
1F2C:  MOVLB  0
1F2E:  BRA    1B70
....................              	}                              
....................                 break; 
1F30:  BRA    2000
....................            //usun karte 
....................            case '3': 
....................                 for(int8 eep=EEPROM_CARD1;eeprom_address<EEPROM_CARD10+1;eeprom_address++){ 
1F32:  MOVLW  10
1F34:  MOVWF  34
1F36:  MOVF   32,W
1F38:  SUBLW  19
1F3A:  BNC   1F90
....................                         printf("%d : %d\n",(eep-EEPROM_CARD1),read_eeprom(eep)); 
1F3C:  MOVLW  10
1F3E:  SUBWF  34,W
1F40:  MOVWF  35
1F42:  MOVFF  FF2,36
1F46:  BCF    FF2.7
1F48:  CLRF   F75
1F4A:  MOVFF  34,F74
1F4E:  BCF    F7F.6
1F50:  BCF    F7F.7
1F52:  BSF    F7F.0
1F54:  MOVF   F73,W
1F56:  BTFSC  36.7
1F58:  BSF    FF2.7
1F5A:  MOVWF  37
1F5C:  MOVFF  35,38
1F60:  MOVLW  18
1F62:  MOVWF  39
1F64:  CALL   0DF8
1F68:  MOVLW  A8
1F6A:  MOVWF  FF6
1F6C:  MOVLW  02
1F6E:  MOVWF  FF7
1F70:  MOVLW  03
1F72:  MOVWF  38
1F74:  CALL   0BF4
1F78:  MOVFF  37,38
1F7C:  MOVLW  18
1F7E:  MOVWF  39
1F80:  CALL   0DF8
1F84:  MOVLW  0A
1F86:  BTFSS  F9E.4
1F88:  BRA    1F86
1F8A:  MOVWF  FAD
1F8C:  INCF   32,F
1F8E:  BRA    1F36
....................                 } 
....................                 printf("Id to remove:\n\n"); 
1F90:  MOVLW  B0
1F92:  MOVWF  FF6
1F94:  MOVLW  02
1F96:  MOVWF  FF7
1F98:  CALL   064E
....................                 c=getc(); 
1F9C:  CALL   126E
1FA0:  MOVFF  01,31
....................                 //c z zakresu od 0 do 9 
....................                 if (c>47 && c<58){ 
1FA4:  MOVF   31,W
1FA6:  SUBLW  2F
1FA8:  BC    1FF4
1FAA:  MOVF   31,W
1FAC:  SUBLW  39
1FAE:  BNC   1FF4
....................                         //przeliczenie z ascii tak by uzyskac numer dec 
....................                         c = c-48; 
1FB0:  MOVLW  30
1FB2:  SUBWF  31,F
....................                         //wykasowanie zawartosci 
....................                         write_eeprom(EEPROM_CARD1+c,0); 
1FB4:  MOVLW  10
1FB6:  ADDWF  31,W
1FB8:  MOVWF  35
1FBA:  MOVF   FF2,W
1FBC:  MOVWF  00
1FBE:  BCF    FF2.7
1FC0:  CLRF   F75
1FC2:  MOVFF  35,F74
1FC6:  CLRF   F73
1FC8:  BCF    F7F.6
1FCA:  BCF    F7F.7
1FCC:  BSF    F7F.2
1FCE:  MOVLB  F
1FD0:  MOVLW  55
1FD2:  MOVWF  F7E
1FD4:  MOVLW  AA
1FD6:  MOVWF  F7E
1FD8:  BSF    F7F.1
1FDA:  BTFSC  F7F.1
1FDC:  BRA    1FDA
1FDE:  BCF    F7F.2
1FE0:  MOVF   00,W
1FE2:  IORWF  FF2,F
....................                         printf("removed\n"); 
1FE4:  MOVLW  C0
1FE6:  MOVWF  FF6
1FE8:  MOVLW  02
1FEA:  MOVWF  FF7
1FEC:  MOVLB  0
1FEE:  CALL   064E
....................                 } 
1FF2:  BRA    2000
....................                 else printf("Wrong id\n"); 
1FF4:  MOVLW  CA
1FF6:  MOVWF  FF6
1FF8:  MOVLW  02
1FFA:  MOVWF  FF7
1FFC:  CALL   064E
....................                 break; 
....................            } 
2000:  GOTO   28FC (RETURN)
.................... } 
....................  
....................  
.................... //----Czy karta jest znana 
.................... unsigned int8 card_know(int8 buffer){ 
*
25EA:  CLRF   30
....................  unsigned int8 know =0; //czy znana karta 1-tak 0-nie 
....................  
....................             //przeszukanie w pamieci czy znana karta 
....................             for(int8 eeprom_address=EEPROM_CARD1;eeprom_address<EEPROM_CARD10+1;eeprom_address++){ 
25EC:  MOVLW  10
25EE:  MOVWF  31
25F0:  MOVF   31,W
25F2:  SUBLW  19
25F4:  BNC   261C
....................                   if (read_eeprom(eeprom_address)== buffer){ 
25F6:  MOVFF  FF2,32
25FA:  BCF    FF2.7
25FC:  CLRF   F75
25FE:  MOVFF  31,F74
2602:  BCF    F7F.6
2604:  BCF    F7F.7
2606:  BSF    F7F.0
2608:  MOVF   F73,W
260A:  BTFSC  32.7
260C:  BSF    FF2.7
260E:  SUBWF  2F,W
2610:  BNZ   2618
....................                           know = 1; 
2612:  MOVLW  01
2614:  MOVWF  30
....................                           break; 
2616:  BRA    261C
....................                   } 
2618:  INCF   31,F
261A:  BRA    25F0
....................             } 
....................   return know; 
261C:  MOVFF  30,01
2620:  GOTO   2CC2 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "functions.c" 
....................  
.................... //wczytuje numer 0-999 z "klawiatury" poprzez UART 
.................... int getnum() 
.................... { 
....................   int a; // Accumulator 
....................   char c; // Current character 
....................   int  d; // Current digit 
....................   int i; // Array index 
....................  
....................   char s[3]; 
....................   printf("["); 
*
22DE:  MOVLW  5B
22E0:  BTFSS  F9E.4
22E2:  BRA    22E0
22E4:  MOVWF  FAD
....................   for(int8 x=0;x<3;x++){ 
22E6:  CLRF   44
22E8:  MOVF   44,W
22EA:  SUBLW  02
22EC:  BNC   2332
....................       s[x] = getc(); 
22EE:  CLRF   03
22F0:  MOVF   44,W
22F2:  ADDLW  41
22F4:  MOVWF  FE9
22F6:  MOVLW  00
22F8:  ADDWFC 03,W
22FA:  MOVWF  FEA
22FC:  MOVFF  FEA,48
2300:  MOVFF  FE9,47
2304:  CALL   126E
2308:  MOVFF  48,FEA
230C:  MOVFF  47,FE9
2310:  MOVFF  01,FEF
....................       printf("%c",s[x]); 
2314:  CLRF   03
2316:  MOVF   44,W
2318:  ADDLW  41
231A:  MOVWF  FE9
231C:  MOVLW  00
231E:  ADDWFC 03,W
2320:  MOVWF  FEA
2322:  MOVFF  FEF,45
2326:  MOVF   45,W
2328:  BTFSS  F9E.4
232A:  BRA    2328
232C:  MOVWF  FAD
232E:  INCF   44,F
2330:  BRA    22E8
....................   } 
....................   printf("]"); 
2332:  MOVLW  5D
2334:  BTFSS  F9E.4
2336:  BRA    2334
2338:  MOVWF  FAD
....................  
....................   i = 0; // Init array index 
233A:  CLRF   40
....................   a = 0; // Init accumulator to zero. 
233C:  CLRF   3D
....................   c = s[i]; // Get first character 
233E:  CLRF   03
2340:  MOVF   40,W
2342:  ADDLW  41
2344:  MOVWF  FE9
2346:  MOVLW  00
2348:  ADDWFC 03,W
234A:  MOVWF  FEA
234C:  MOVFF  FEF,3E
....................   i++; //Advance the index 
2350:  INCF   40,F
....................  
....................   // Convert while not null terminator and is a numeric character 
....................   while((c!=0)&&(c>='0')&&(c<='9')) 
2352:  MOVF   3E,F
2354:  BZ    238A
2356:  MOVF   3E,W
2358:  SUBLW  2F
235A:  BC    238A
235C:  MOVF   3E,W
235E:  SUBLW  39
2360:  BNC   238A
....................   { 
....................     d = c - '0'; // Convert character to digit 
2362:  MOVLW  30
2364:  SUBWF  3E,W
2366:  MOVWF  3F
....................     a = a * 10;  // Make room for digit 
2368:  MOVF   3D,W
236A:  MULLW  0A
236C:  MOVFF  FF3,3D
....................     a = a + d; // Add digit to accumulator 
2370:  MOVF   3F,W
2372:  ADDWF  3D,F
....................     c = s[i]; // Get next character 
2374:  CLRF   03
2376:  MOVF   40,W
2378:  ADDLW  41
237A:  MOVWF  FE9
237C:  MOVLW  00
237E:  ADDWFC 03,W
2380:  MOVWF  FEA
2382:  MOVFF  FEF,3E
....................     i++; //Advance the index 
2386:  INCF   40,F
2388:  BRA    2352
....................   } 
....................   return(a); 
238A:  MOVFF  3D,01
238E:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... void clear_buffer(){ 
....................    for(int8 x=0;x<8;x++){ 
*
0C5C:  CLRF   32
0C5E:  MOVF   32,W
0C60:  SUBLW  07
0C62:  BNC   0C78
....................       buffer[x]=0; 
0C64:  CLRF   03
0C66:  MOVF   32,W
0C68:  ADDLW  16
0C6A:  MOVWF  FE9
0C6C:  MOVLW  00
0C6E:  ADDWFC 03,W
0C70:  MOVWF  FEA
0C72:  CLRF   FEF
0C74:  INCF   32,F
0C76:  BRA    0C5E
....................    } 
0C78:  RETURN 0
.................... } 
....................  
....................  
.................... void sendalarmstate(){ 
....................    //wyslanie stanu do czytnika 
....................    clear_buffer(); 
*
0EAA:  RCALL  0C5C
....................    buffer[0]='a'; 
0EAC:  MOVLW  61
0EAE:  MOVWF  16
....................    buffer[1]=state; 
0EB0:  MOVFF  07,17
....................    can_putd(CAN_BROADCAST_ID, buffer, sizeof(buffer), 1, 1, 0); 
0EB4:  CLRF   3E
0EB6:  CLRF   3D
0EB8:  CLRF   3C
0EBA:  MOVLW  01
0EBC:  MOVWF  3B
0EBE:  CLRF   40
0EC0:  MOVLW  16
0EC2:  MOVWF  3F
0EC4:  MOVLW  08
0EC6:  MOVWF  41
0EC8:  MOVLW  01
0ECA:  MOVWF  42
0ECC:  MOVWF  43
0ECE:  CLRF   44
0ED0:  RCALL  0C7A
....................    printf("\nMessage To CAN: %d %d %d %d %d %d %d %d \n",buffer[0],buffer[1],buffer[2],buffer[3],buffer[4],buffer[5],buffer[6],buffer[7]); 
0ED2:  MOVLW  D4
0ED4:  MOVWF  FF6
0ED6:  MOVLW  02
0ED8:  MOVWF  FF7
0EDA:  MOVLW  11
0EDC:  MOVWF  38
0EDE:  RCALL  0BF4
0EE0:  MOVFF  16,38
0EE4:  MOVLW  18
0EE6:  MOVWF  39
0EE8:  RCALL  0DF8
0EEA:  MOVLW  20
0EEC:  BTFSS  F9E.4
0EEE:  BRA    0EEC
0EF0:  MOVWF  FAD
0EF2:  MOVFF  17,38
0EF6:  MOVLW  18
0EF8:  MOVWF  39
0EFA:  RCALL  0DF8
0EFC:  MOVLW  20
0EFE:  BTFSS  F9E.4
0F00:  BRA    0EFE
0F02:  MOVWF  FAD
0F04:  MOVFF  18,38
0F08:  MOVLW  18
0F0A:  MOVWF  39
0F0C:  RCALL  0DF8
0F0E:  MOVLW  20
0F10:  BTFSS  F9E.4
0F12:  BRA    0F10
0F14:  MOVWF  FAD
0F16:  MOVFF  19,38
0F1A:  MOVLW  18
0F1C:  MOVWF  39
0F1E:  RCALL  0DF8
0F20:  MOVLW  20
0F22:  BTFSS  F9E.4
0F24:  BRA    0F22
0F26:  MOVWF  FAD
0F28:  MOVFF  1A,38
0F2C:  MOVLW  18
0F2E:  MOVWF  39
0F30:  RCALL  0DF8
0F32:  MOVLW  20
0F34:  BTFSS  F9E.4
0F36:  BRA    0F34
0F38:  MOVWF  FAD
0F3A:  MOVFF  1B,38
0F3E:  MOVLW  18
0F40:  MOVWF  39
0F42:  RCALL  0DF8
0F44:  MOVLW  20
0F46:  BTFSS  F9E.4
0F48:  BRA    0F46
0F4A:  MOVWF  FAD
0F4C:  MOVFF  1C,38
0F50:  MOVLW  18
0F52:  MOVWF  39
0F54:  RCALL  0DF8
0F56:  MOVLW  20
0F58:  BTFSS  F9E.4
0F5A:  BRA    0F58
0F5C:  MOVWF  FAD
0F5E:  MOVFF  1D,38
0F62:  MOVLW  18
0F64:  MOVWF  39
0F66:  RCALL  0DF8
0F68:  MOVLW  20
0F6A:  BTFSS  F9E.4
0F6C:  BRA    0F6A
0F6E:  MOVWF  FAD
0F70:  MOVLW  0A
0F72:  BTFSS  F9E.4
0F74:  BRA    0F72
0F76:  MOVWF  FAD
0F78:  RETURN 0
.................... } 
....................  
.................... void state_monitor(){ 
....................    //sprawdzenie czy zmienil sie stan urzadzenia i podjecie dzialan 
....................    if (state != reg_state){ 
*
103E:  MOVF   08,W
1040:  SUBWF  07,W
1042:  BZ    1086
....................          reg_state = state; 
1044:  MOVFF  07,08
....................         write_eeprom(EEPROM_REGSTATE,state); 
1048:  MOVF   FF2,W
104A:  MOVWF  00
104C:  BCF    FF2.7
104E:  CLRF   F75
1050:  MOVLW  21
1052:  MOVWF  F74
1054:  MOVFF  07,F73
1058:  BCF    F7F.6
105A:  BCF    F7F.7
105C:  BSF    F7F.2
105E:  MOVLB  F
1060:  MOVLW  55
1062:  MOVWF  F7E
1064:  MOVLW  AA
1066:  MOVWF  F7E
1068:  BSF    F7F.1
106A:  BTFSC  F7F.1
106C:  BRA    106A
106E:  BCF    F7F.2
1070:  MOVF   00,W
1072:  IORWF  FF2,F
....................         //wyslanie stanu do klawiatury 
....................         sendalarmstate(); 
1074:  MOVLB  0
1076:  RCALL  0EAA
....................         //jesli alarm, wlaczenie syreny 
....................         if (state == st_alarm){ 
1078:  MOVF   07,W
107A:  SUBLW  02
107C:  BNZ   1080
....................              sirene_on(); 
107E:  RCALL  0C14
....................          } 
....................         //jesli rozbrojony, wylaczenie syreny 
....................         if (state == st_unarmed){ 
1080:  MOVF   07,F
1082:  BNZ   1086
....................                sirene_off(); 
1084:  RCALL  0F7A
....................          } 
....................    } 
1086:  GOTO   271C (RETURN)
.................... } 
....................  
.................... //rozgloszenie istnienia urzadzenia w sieci 
.................... void caniamlive(){ 
....................         delay_ms(10*CAN_ALARM_ID); 
*
25B2:  MOVLW  C8
25B4:  MOVWF  30
25B6:  CALL   0628
....................         clear_buffer(); 
25BA:  CALL   0C5C
....................         buffer[0] = 'L'; 
25BE:  MOVLW  4C
25C0:  MOVWF  16
....................         buffer[1] = CAN_ALARM_ID; 
25C2:  MOVLW  14
25C4:  MOVWF  17
....................         can_putd(CAN_BROADCAST_ID, buffer, sizeof(buffer), 1, 1, 0); 
25C6:  CLRF   3E
25C8:  CLRF   3D
25CA:  CLRF   3C
25CC:  MOVLW  01
25CE:  MOVWF  3B
25D0:  CLRF   40
25D2:  MOVLW  16
25D4:  MOVWF  3F
25D6:  MOVLW  08
25D8:  MOVWF  41
25DA:  MOVLW  01
25DC:  MOVWF  42
25DE:  MOVWF  43
25E0:  CLRF   44
25E2:  CALL   0C7A
25E6:  GOTO   2C72 (RETURN)
.................... } 
....................  
....................  
.................... #include "can_tools.c" 
....................  
.................... //wywolaj wszystkie urzadzenia na can 
.................... void candiscover(){ 
....................        clear_buffer(); 
*
22B2:  CALL   0C5C
....................        buffer[0] = 'P'; 
22B6:  MOVLW  50
22B8:  MOVWF  16
....................        can_putd(CAN_BROADCAST_ID, buffer, sizeof(buffer), 1, 1, 0); 
22BA:  CLRF   3E
22BC:  CLRF   3D
22BE:  CLRF   3C
22C0:  MOVLW  01
22C2:  MOVWF  3B
22C4:  CLRF   40
22C6:  MOVLW  16
22C8:  MOVWF  3F
22CA:  MOVLW  08
22CC:  MOVWF  41
22CE:  MOVLW  01
22D0:  MOVWF  42
22D2:  MOVWF  43
22D4:  CLRF   44
22D6:  CALL   0C7A
22DA:  GOTO   248A (RETURN)
.................... } 
....................  
....................  
.................... //wyslanie komunikatu na can - manualnie 
.................... void canmanualmsg(){ 
....................      
....................     printf("\nRecipient Id:"); 
*
2390:  MOVLW  00
2392:  MOVWF  FF6
2394:  MOVLW  03
2396:  MOVWF  FF7
2398:  CALL   064E
....................     int8 id =  getnum(); 
239C:  RCALL  22DE
239E:  MOVFF  01,30
....................     printf("\n msg:"); 
23A2:  MOVLW  10
23A4:  MOVWF  FF6
23A6:  MOVLW  03
23A8:  MOVWF  FF7
23AA:  CALL   064E
....................   
....................     int8 a[8];   
....................     for(int8 x=0; x<8; x++){ 
23AE:  CLRF   39
23B0:  MOVF   39,W
23B2:  SUBLW  07
23B4:  BNC   23DC
....................       a[x] = getnum(); 
23B6:  CLRF   03
23B8:  MOVF   39,W
23BA:  ADDLW  31
23BC:  MOVWF  01
23BE:  MOVLW  00
23C0:  ADDWFC 03,F
23C2:  MOVFF  01,3B
23C6:  MOVFF  03,3C
23CA:  RCALL  22DE
23CC:  MOVFF  3C,FEA
23D0:  MOVFF  3B,FE9
23D4:  MOVFF  01,FEF
23D8:  INCF   39,F
23DA:  BRA    23B0
....................     } 
....................      
....................     printf("\nSend y/n"); 
23DC:  MOVLW  18
23DE:  MOVWF  FF6
23E0:  MOVLW  03
23E2:  MOVWF  FF7
23E4:  CALL   064E
....................     char c=getc(); 
23E8:  CALL   126E
23EC:  MOVFF  01,3A
....................     switch (c){ 
23F0:  MOVF   3A,W
23F2:  XORLW  79
23F4:  BZ    23FC
23F6:  XORLW  17
23F8:  BZ    241E
23FA:  BRA    2420
....................             case 'y':  can_putd(id, a, sizeof(a), 1, 1, 0); break; 
23FC:  CLRF   3E
23FE:  CLRF   3D
2400:  CLRF   3C
2402:  MOVFF  30,3B
2406:  CLRF   40
2408:  MOVLW  31
240A:  MOVWF  3F
240C:  MOVLW  08
240E:  MOVWF  41
2410:  MOVLW  01
2412:  MOVWF  42
2414:  MOVWF  43
2416:  CLRF   44
2418:  CALL   0C7A
241C:  BRA    2420
....................             case 'n':  break; 
241E:  BRA    2420
....................             default: break; 
....................    } 
....................   printf("\nok"); 
2420:  MOVLW  22
2422:  MOVWF  FF6
2424:  MOVLW  03
2426:  MOVWF  FF7
2428:  CALL   064E
242C:  GOTO   248A (RETURN)
.................... } 
....................  
.................... void cantools(){ 
....................    printf("\n---------CAN TOOLS---------\n");            
2430:  MOVLW  26
2432:  MOVWF  FF6
2434:  MOVLW  03
2436:  MOVWF  FF7
2438:  CALL   064E
....................    printf("1 - discover devices\n"); 
243C:  MOVLW  44
243E:  MOVWF  FF6
2440:  MOVLW  03
2442:  MOVWF  FF7
2444:  CALL   064E
....................    printf("2 - send message on can\n"); 
2448:  MOVLW  5A
244A:  MOVWF  FF6
244C:  MOVLW  03
244E:  MOVWF  FF7
2450:  CALL   064E
....................  
....................    while (kbhit()); 
2454:  BTFSC  F9E.5
2456:  BRA    2454
....................  
....................    char c=getc(); 
2458:  CALL   126E
245C:  MOVFF  01,2F
....................    switch (c){ 
2460:  MOVF   2F,W
2462:  XORLW  31
2464:  BZ    246C
2466:  XORLW  03
2468:  BZ    247C
246A:  BRA    248A
....................             case '1': printf(">devices on CAN:\n"); candiscover(); break; 
246C:  MOVLW  74
246E:  MOVWF  FF6
2470:  MOVLW  03
2472:  MOVWF  FF7
2474:  CALL   064E
2478:  BRA    22B2
247A:  BRA    248A
....................             case '2': printf(">NOT IMPLEMENTED\n"); canmanualmsg(); break; 
247C:  MOVLW  86
247E:  MOVWF  FF6
2480:  MOVLW  03
2482:  MOVWF  FF7
2484:  CALL   064E
2488:  BRA    2390
....................    } 
248A:  GOTO   28FC (RETURN)
.................... } 
....................  
.................... #include "lightstation_admin.c" 
.................... //wlaczanie swiatla z modulacja 
.................... void softlight(){ 
....................     clear_buffer(); 
248E:  CALL   0C5C
....................     buffer[0]='m'; //modulacja swiatlem sciemnianie i rozjasnianie 
2492:  MOVLW  6D
2494:  MOVWF  16
....................  
....................     printf("\n>Soft light modulation for LED"); 
2496:  MOVLW  98
2498:  MOVWF  FF6
249A:  MOVLW  03
249C:  MOVWF  FF7
249E:  CALL   064E
....................  
....................     printf("\nLight station Id:"); 
24A2:  MOVLW  B8
24A4:  MOVWF  FF6
24A6:  MOVLW  03
24A8:  MOVWF  FF7
24AA:  CALL   064E
....................     int8 id =  getnum(); 
24AE:  RCALL  22DE
24B0:  MOVFF  01,30
....................     buffer[1]=id; 
24B4:  MOVFF  30,17
....................  
....................     printf("\nactivation y/n"); 
24B8:  MOVLW  CC
24BA:  MOVWF  FF6
24BC:  MOVLW  03
24BE:  MOVWF  FF7
24C0:  CALL   064E
....................     char c=getc(); 
24C4:  CALL   126E
24C8:  MOVFF  01,31
....................     switch (c){ 
24CC:  MOVF   31,W
24CE:  XORLW  79
24D0:  BZ    24D8
24D2:  XORLW  17
24D4:  BZ    24DE
24D6:  BRA    24E0
....................             case 'y': buffer[2]=1; break; 
24D8:  MOVLW  01
24DA:  MOVWF  18
24DC:  BRA    24E0
....................             case 'n': buffer[2]=0; break;               
24DE:  CLRF   18
....................     } 
....................     can_putd(CAN_LIGHTSTATION_ID, buffer, sizeof(buffer), 1, 1, 0);    
24E0:  CLRF   3E
24E2:  CLRF   3D
24E4:  CLRF   3C
24E6:  MOVLW  16
24E8:  MOVWF  3B
24EA:  CLRF   40
24EC:  MOVWF  3F
24EE:  MOVLW  08
24F0:  MOVWF  41
24F2:  MOVLW  01
24F4:  MOVWF  42
24F6:  MOVWF  43
24F8:  CLRF   44
24FA:  CALL   0C7A
....................     printf("\nok"); 
24FE:  MOVLW  DC
2500:  MOVWF  FF6
2502:  MOVLW  03
2504:  MOVWF  FF7
2506:  CALL   064E
250A:  GOTO   25AE (RETURN)
.................... } 
....................  
.................... //wlaczenie swiatla po wykryciu ruchu 
.................... void setlightontik(){ 
....................     clear_buffer(); 
250E:  CALL   0C5C
....................     buffer[0]='l'; 
2512:  MOVLW  6C
2514:  MOVWF  16
....................  
....................     printf("\nlight on motion y/n"); 
2516:  MOVLW  E0
2518:  MOVWF  FF6
251A:  MOVLW  03
251C:  MOVWF  FF7
251E:  CALL   064E
....................     char c=getc(); 
2522:  CALL   126E
2526:  MOVFF  01,30
....................     switch (c){ 
252A:  MOVF   30,W
252C:  XORLW  79
252E:  BZ    2536
2530:  XORLW  17
2532:  BZ    253C
2534:  BRA    253E
....................             case 'y': buffer[1]=1; break; 
2536:  MOVLW  01
2538:  MOVWF  17
253A:  BRA    253E
....................             case 'n': buffer[1]=0; break;               
253C:  CLRF   17
....................     } 
....................     can_putd(CAN_LIGHTSTATION_ID, buffer, sizeof(buffer), 1, 1, 0);    
253E:  CLRF   3E
2540:  CLRF   3D
2542:  CLRF   3C
2544:  MOVLW  16
2546:  MOVWF  3B
2548:  CLRF   40
254A:  MOVWF  3F
254C:  MOVLW  08
254E:  MOVWF  41
2550:  MOVLW  01
2552:  MOVWF  42
2554:  MOVWF  43
2556:  CLRF   44
2558:  CALL   0C7A
....................     printf("\nok"); 
255C:  MOVLW  F6
255E:  MOVWF  FF6
2560:  MOVLW  03
2562:  MOVWF  FF7
2564:  CALL   064E
2568:  GOTO   25AE (RETURN)
.................... } 
....................  
.................... void lightstationadmin(){ 
....................    printf("\n----LIGHTSTATION ADMIN-----\n");               
256C:  MOVLW  FA
256E:  MOVWF  FF6
2570:  MOVLW  03
2572:  MOVWF  FF7
2574:  CALL   064E
....................    printf("1 - soft light\n"); 
2578:  MOVLW  18
257A:  MOVWF  FF6
257C:  MOVLW  04
257E:  MOVWF  FF7
2580:  CALL   064E
....................    printf("2 - light on motion\n"); 
2584:  MOVLW  28
2586:  MOVWF  FF6
2588:  MOVLW  04
258A:  MOVWF  FF7
258C:  CALL   064E
....................  
....................    while (kbhit()); 
2590:  BTFSC  F9E.5
2592:  BRA    2590
....................  
....................    char c=getc(); 
2594:  CALL   126E
2598:  MOVFF  01,2F
....................    switch (c){ 
259C:  MOVF   2F,W
259E:  XORLW  31
25A0:  BZ    25A8
25A2:  XORLW  03
25A4:  BZ    25AC
25A6:  BRA    25AE
....................             case '1': softlight(); break; 
25A8:  BRA    248E
25AA:  BRA    25AE
....................             case '2': setlightontik(); break; 
25AC:  BRA    250E
....................             
....................    } 
25AE:  GOTO   28FC (RETURN)
.................... } 
....................  
....................  
.................... //======================================  
.................... void main(void)  
*
2624:  CLRF   FF8
2626:  BCF    FD0.7
2628:  MOVLW  62
262A:  MOVWF  FD3
262C:  CLRF   F9B
262E:  CLRF   F64
2630:  CLRF   04
2632:  BCF    FA7.3
2634:  MOVLW  0C
2636:  MOVWF  FAF
2638:  MOVLW  A2
263A:  MOVWF  FAC
263C:  MOVLW  90
263E:  MOVWF  FAB
2640:  CLRF   29
2642:  CLRF   2A
2644:  SETF   2B
2646:  MOVLB  F
2648:  MOVF   x5C,W
264A:  ANDLW  80
264C:  MOVWF  x5C
264E:  MOVLW  00
2650:  MOVWF  x5D
2652:  BCF    FC1.3
2654:  BCF    FC1.4
2656:  BCF    FC1.5
2658:  CLRF   x5E
265A:  CLRF   x5F
.................... { 
....................  //odczekanie po podlaczeniu zasilania 
....................  delay_ms(500); 
265C:  MOVLW  02
265E:  MOVWF  2F
2660:  MOVLW  FA
2662:  MOVWF  30
2664:  MOVLB  0
2666:  CALL   0628
266A:  DECFSZ 2F,F
266C:  BRA    2670
266E:  BRA    2674
2670:  MOVLB  F
2672:  BRA    2660
....................   
....................  printf("\nAlarm ok\n\n"); 
2674:  MOVLW  3E
2676:  MOVWF  FF6
2678:  MOVLW  04
267A:  MOVWF  FF7
267C:  CALL   064E
....................  blinkgreenred(100); 
2680:  MOVLW  64
2682:  MOVWF  2F
2684:  CALL   0670
....................   
....................  //initlines(); // wykrycie czujek na liniach 
....................  can_init();  // inicjacja can 
2688:  GOTO   0806
....................   
....................  int i = 0; 
268C:  CLRF   2C
....................  
.................... //jesli alarm byl w stanie uzbrojenia, alarmu, postalarmu i zostal wylaczony odczytujemy jego stan  
.................... if(read_eeprom(EEPROM_REGSTATE)>0 && read_eeprom(EEPROM_REGSTATE)<4){ 
268E:  MOVFF  FF2,2F
2692:  BCF    FF2.7
2694:  CLRF   F75
2696:  MOVLW  21
2698:  MOVWF  F74
269A:  BCF    F7F.6
269C:  BCF    F7F.7
269E:  BSF    F7F.0
26A0:  MOVF   F73,W
26A2:  BTFSC  2F.7
26A4:  BSF    FF2.7
26A6:  XORLW  00
26A8:  BZ    2706
26AA:  MOVFF  FF2,30
26AE:  BCF    FF2.7
26B0:  CLRF   F75
26B2:  MOVLW  21
26B4:  MOVWF  F74
26B6:  BCF    F7F.6
26B8:  BCF    F7F.7
26BA:  BSF    F7F.0
26BC:  MOVF   F73,W
26BE:  BTFSC  30.7
26C0:  BSF    FF2.7
26C2:  SUBLW  03
26C4:  BNC   2706
....................      state = read_eeprom(EEPROM_REGSTATE); 
26C6:  MOVFF  FF2,2F
26CA:  BCF    FF2.7
26CC:  CLRF   F75
26CE:  MOVLW  21
26D0:  MOVWF  F74
26D2:  BCF    F7F.6
26D4:  BCF    F7F.7
26D6:  BSF    F7F.0
26D8:  MOVF   F73,W
26DA:  BTFSC  2F.7
26DC:  BSF    FF2.7
26DE:  MOVWF  07
....................      reg_state = read_eeprom(EEPROM_REGSTATE); 
26E0:  MOVFF  FF2,2F
26E4:  BCF    FF2.7
26E6:  CLRF   F75
26E8:  MOVLW  21
26EA:  MOVWF  F74
26EC:  BCF    F7F.6
26EE:  BCF    F7F.7
26F0:  BSF    F7F.0
26F2:  MOVF   F73,W
26F4:  BTFSC  2F.7
26F6:  BSF    FF2.7
26F8:  MOVWF  08
....................      //jesli odlaczono w stanie alarmu, to nalezy uaktywnic syrene 
....................      if (state==st_alarm){ 
26FA:  MOVF   07,W
26FC:  SUBLW  02
26FE:  BNZ   2704
....................           sirene_on(); 
2700:  CALL   0C14
....................      } 
.................... } 
2704:  BRA    270A
.................... //centrala uruchamiana na swiezo 
.................... else { 
....................      state = st_unarmed; 
2706:  CLRF   07
....................      reg_state = st_unarmed; 
2708:  CLRF   08
.................... } 
....................  
....................  sendalarmstate(); 
270A:  CALL   0EAA
....................   
....................  while(1)  
....................   { 
....................  
.................... //jesli jest alarm to wyjemy syrena tyle ile jest ustawione 
....................  if (state == st_alarm){ 
270E:  MOVF   07,W
2710:  SUBLW  02
2712:  BNZ   2718
....................              sirene_delay(); 
2714:  GOTO   0FBE
....................  } 
....................    //sprawdzanie czy zmienil sie stan urzadzenia np. z czuwania na alarm 
....................    state_monitor(); 
2718:  GOTO   103E
....................     
....................    //informacja o stanie na kontrolkach 
....................    led_state_display(); 
271C:  GOTO   10B2
....................     
....................    //analiza stanu na liniach wykryla alarm        
....................    if (watchlines()!=0){ 
2720:  CALL   1106
2724:  MOVF   01,F
2726:  BZ    2792
....................              int8 z = watchlines(); 
2728:  CALL   1106
272C:  MOVFF  01,2D
....................              //pobranie odczekiwania dla danej linii przy pierwszym wywolaniu 
....................         if (alarm_delay==-1){ 
2730:  MOVF   2B,W
2732:  SUBLW  FF
2734:  BNZ   2744
....................          //pobranie wartosci odczekiwania dla danej linii 
....................          alarm_delay=line_wait(z); 
2736:  MOVFF  2D,2F
273A:  CALL   11AA
273E:  MOVFF  01,2B
....................         } 
2742:  BRA    275E
....................         //zmniejszenie czasu odczekiwania jesli  
....................              //jest on mniejszy od aktualnie odczekiwanego 
....................         else{ 
....................       if (line_wait(z)<alarm_delay){ 
2744:  MOVFF  2D,2F
2748:  CALL   11AA
274C:  MOVF   2B,W
274E:  SUBWF  01,W
2750:  BC    275E
....................          alarm_delay=line_wait(z); 
2752:  MOVFF  2D,2F
2756:  CALL   11AA
275A:  MOVFF  01,2B
....................       } 
....................         } 
....................  
....................  
....................              //jesli jest uzbrojony         
....................              if((state == st_armed) || (state == st_postalarm)){ 
275E:  DECFSZ 07,W
2760:  BRA    2764
2762:  BRA    276A
2764:  MOVF   07,W
2766:  SUBLW  03
2768:  BNZ   2792
....................                    alarm(z); 
....................              } 
....................     } 
....................      
....................      
....................     //nacisniecie przycisku set 
....................     if (input(SET) == true){ 
*
2792:  BSF    F93.1
2794:  BTFSS  F81.1
2796:  BRA    27AE
....................                 //jesli byl uzbrojony, to rozbroic 
....................                 if (state == st_armed){ 
2798:  DECFSZ 07,W
279A:  BRA    27AE
....................                         printf("unarmed\n"); 
279C:  MOVLW  4A
279E:  MOVWF  FF6
27A0:  MOVLW  04
27A2:  MOVWF  FF7
27A4:  CALL   064E
....................                         state = st_unarmed; 
27A8:  CLRF   07
....................                         //wyslanie stanu do czytnika 
....................                         sendalarmstate(); 
27AA:  CALL   0EAA
....................                 } 
....................                 //jesli byl rozbrojony 
....................                 else { } 
....................     } 
....................      
....................     //otrzymanie komunikatu z uart 
....................     if(kbhit()) { 
27AE:  BTFSS  F9E.5
27B0:  BRA    290C
....................         char c=getc(); 
27B2:  CALL   126E
27B6:  MOVFF  01,2E
....................         //jesli jest rozbrojony 
....................         if (state == st_unarmed){ 
27BA:  MOVF   07,F
27BC:  BTFSS  FD8.2
27BE:  BRA    28FC
....................                 switch (c){ 
27C0:  MOVF   2E,W
27C2:  XORLW  31
27C4:  BZ    27E8
27C6:  XORLW  03
27C8:  BZ    27FA
27CA:  XORLW  01
27CC:  BZ    280C
27CE:  XORLW  07
27D0:  BZ    281E
27D2:  XORLW  01
27D4:  BZ    2830
27D6:  XORLW  03
27D8:  BZ    2842
27DA:  XORLW  01
27DC:  BZ    2852
27DE:  XORLW  0F
27E0:  BZ    2864
27E2:  XORLW  01
27E4:  BZ    2868
27E6:  BRA    286C
....................                            case '1': printf(">lines auto config\n"); initlines(); break; 
27E8:  MOVLW  54
27EA:  MOVWF  FF6
27EC:  MOVLW  04
27EE:  MOVWF  FF7
27F0:  CALL   064E
27F4:  GOTO   1284
27F8:  BRA    28FC
....................                            case '2': printf(">lines config\n"); lines_config(); break; 
27FA:  MOVLW  68
27FC:  MOVWF  FF6
27FE:  MOVLW  04
2800:  MOVWF  FF7
2802:  CALL   064E
2806:  GOTO   1508
280A:  BRA    28FC
....................                            case '3': printf(">lines monitor\n"); lines_monitor(); break; 
280C:  MOVLW  78
280E:  MOVWF  FF6
2810:  MOVLW  04
2812:  MOVWF  FF7
2814:  CALL   064E
2818:  GOTO   176A
281C:  BRA    28FC
....................                            case '4': printf(">sirene config\n"); sirene_config(); break; 
281E:  MOVLW  88
2820:  MOVWF  FF6
2822:  MOVLW  04
2824:  MOVWF  FF7
2826:  CALL   064E
282A:  GOTO   17EA
282E:  BRA    28FC
....................                            case '5': printf(">cards\n"); cards_config(); break; 
2830:  MOVLW  98
2832:  MOVWF  FF6
2834:  MOVLW  04
2836:  MOVWF  FF7
2838:  CALL   064E
283C:  GOTO   1AC2
2840:  BRA    28FC
....................                            case '6': printf(">time\n"); time_config(); break; 
2842:  MOVLW  A0
2844:  MOVWF  FF6
2846:  MOVLW  04
2848:  MOVWF  FF7
284A:  CALL   064E
284E:  BRA    2140
2850:  BRA    28FC
....................                            case '7': printf(">armed\n"); state = st_armed; break; 
2852:  MOVLW  A8
2854:  MOVWF  FF6
2856:  MOVLW  04
2858:  MOVWF  FF7
285A:  CALL   064E
285E:  MOVLW  01
2860:  MOVWF  07
2862:  BRA    28FC
....................                            case '8': cantools(); break; 
2864:  BRA    2430
2866:  BRA    28FC
....................                            case '9': lightstationadmin(); break; 
2868:  BRA    256C
286A:  BRA    28FC
....................                            default:  
....................                                 printf("\n---------------------------\n");  
286C:  MOVLW  B0
286E:  MOVWF  FF6
2870:  MOVLW  04
2872:  MOVWF  FF7
2874:  CALL   064E
....................                                 printf("Main menu alarm central\n");  
2878:  MOVLW  CE
287A:  MOVWF  FF6
287C:  MOVLW  04
287E:  MOVWF  FF7
2880:  CALL   064E
....................                                 printf("---------------------------\n\n");  
2884:  MOVLW  E8
2886:  MOVWF  FF6
2888:  MOVLW  04
288A:  MOVWF  FF7
288C:  CALL   064E
....................                                 printf("1 - lines auto config\n");  
2890:  MOVLW  06
2892:  MOVWF  FF6
2894:  MOVLW  05
2896:  MOVWF  FF7
2898:  CALL   064E
....................                                 printf("2 - lines config\n"); 
289C:  MOVLW  1E
289E:  MOVWF  FF6
28A0:  MOVLW  05
28A2:  MOVWF  FF7
28A4:  CALL   064E
....................                                 printf("3 - lines monitor\n"); 
28A8:  MOVLW  30
28AA:  MOVWF  FF6
28AC:  MOVLW  05
28AE:  MOVWF  FF7
28B0:  CALL   064E
....................                                 printf("4 - sirene config\n"); 
28B4:  MOVLW  44
28B6:  MOVWF  FF6
28B8:  MOVLW  05
28BA:  MOVWF  FF7
28BC:  CALL   064E
....................                                 printf("5 - cards\n"); 
28C0:  MOVLW  58
28C2:  MOVWF  FF6
28C4:  MOVLW  05
28C6:  MOVWF  FF7
28C8:  CALL   064E
....................                                 printf("6 - time\n"); 
28CC:  MOVLW  64
28CE:  MOVWF  FF6
28D0:  MOVLW  05
28D2:  MOVWF  FF7
28D4:  CALL   064E
....................                                 printf("7 - arm\n"); 
28D8:  MOVLW  6E
28DA:  MOVWF  FF6
28DC:  MOVLW  05
28DE:  MOVWF  FF7
28E0:  CALL   064E
....................                                 printf("8 - CAN tools\n"); 
28E4:  MOVLW  78
28E6:  MOVWF  FF6
28E8:  MOVLW  05
28EA:  MOVWF  FF7
28EC:  CALL   064E
....................                                 printf("9 - LightStation admin\n"); 
28F0:  MOVLW  88
28F2:  MOVWF  FF6
28F4:  MOVLW  05
28F6:  MOVWF  FF7
28F8:  CALL   064E
....................                                 break; 
....................                 } 
....................         } 
....................         //jesli uzbrojony 
....................         if (state == st_armed){ 
28FC:  DECFSZ 07,W
28FE:  BRA    290C
....................                 printf("First press SET button to disarm\n"); 
2900:  MOVLW  A0
2902:  MOVWF  FF6
2904:  MOVLW  05
2906:  MOVWF  FF7
2908:  CALL   064E
....................         } 
....................     } 
....................      
....................     //otrzymanie komunikatu z can     
....................     if(can_getd(rx_id, buffer, rx_len, rxstat)) {  
290C:  CLRF   36
290E:  MOVLW  16
2910:  MOVWF  35
*
2B82:  MOVF   01,F
2B84:  BTFSC  FD8.2
2B86:  BRA    2D20
....................        if(rx_id == CAN_ALARM_ID || rx_id ==  CAN_BROADCAST_ID) {  
2B88:  MOVF   0D,W
2B8A:  SUBLW  14
2B8C:  BNZ   2B9A
2B8E:  MOVF   0E,F
2B90:  BNZ   2B9A
2B92:  MOVF   0F,F
2B94:  BNZ   2B9A
2B96:  MOVF   10,F
2B98:  BZ    2BB0
2B9A:  DECFSZ 0D,W
2B9C:  BRA    2D20
2B9E:  MOVF   0E,F
2BA0:  BTFSS  FD8.2
2BA2:  BRA    2D20
2BA4:  MOVF   0F,F
2BA6:  BTFSS  FD8.2
2BA8:  BRA    2D20
2BAA:  MOVF   10,F
2BAC:  BTFSS  FD8.2
2BAE:  BRA    2D20
....................         //pokazanie otrzymanego komunikatu z CAN 
....................         printf("\nMessage From CAN: %d %d %d %d %d %d %d %d \n",buffer[0],buffer[1],buffer[2],buffer[3],buffer[4],buffer[5],buffer[6],buffer[7]); 
2BB0:  MOVLW  C2
2BB2:  MOVWF  FF6
2BB4:  MOVLW  05
2BB6:  MOVWF  FF7
2BB8:  MOVLW  13
2BBA:  MOVWF  38
2BBC:  MOVLB  0
2BBE:  CALL   0BF4
2BC2:  MOVFF  16,38
2BC6:  MOVLW  18
2BC8:  MOVWF  39
2BCA:  CALL   0DF8
2BCE:  MOVLW  20
2BD0:  BTFSS  F9E.4
2BD2:  BRA    2BD0
2BD4:  MOVWF  FAD
2BD6:  MOVFF  17,38
2BDA:  MOVLW  18
2BDC:  MOVWF  39
2BDE:  CALL   0DF8
2BE2:  MOVLW  20
2BE4:  BTFSS  F9E.4
2BE6:  BRA    2BE4
2BE8:  MOVWF  FAD
2BEA:  MOVFF  18,38
2BEE:  MOVLW  18
2BF0:  MOVWF  39
2BF2:  CALL   0DF8
2BF6:  MOVLW  20
2BF8:  BTFSS  F9E.4
2BFA:  BRA    2BF8
2BFC:  MOVWF  FAD
2BFE:  MOVFF  19,38
2C02:  MOVLW  18
2C04:  MOVWF  39
2C06:  CALL   0DF8
2C0A:  MOVLW  20
2C0C:  BTFSS  F9E.4
2C0E:  BRA    2C0C
2C10:  MOVWF  FAD
2C12:  MOVFF  1A,38
2C16:  MOVLW  18
2C18:  MOVWF  39
2C1A:  CALL   0DF8
2C1E:  MOVLW  20
2C20:  BTFSS  F9E.4
2C22:  BRA    2C20
2C24:  MOVWF  FAD
2C26:  MOVFF  1B,38
2C2A:  MOVLW  18
2C2C:  MOVWF  39
2C2E:  CALL   0DF8
2C32:  MOVLW  20
2C34:  BTFSS  F9E.4
2C36:  BRA    2C34
2C38:  MOVWF  FAD
2C3A:  MOVFF  1C,38
2C3E:  MOVLW  18
2C40:  MOVWF  39
2C42:  CALL   0DF8
2C46:  MOVLW  20
2C48:  BTFSS  F9E.4
2C4A:  BRA    2C48
2C4C:  MOVWF  FAD
2C4E:  MOVFF  1D,38
2C52:  MOVLW  18
2C54:  MOVWF  39
2C56:  CALL   0DF8
2C5A:  MOVLW  20
2C5C:  BTFSS  F9E.4
2C5E:  BRA    2C5C
2C60:  MOVWF  FAD
2C62:  MOVLW  0A
2C64:  BTFSS  F9E.4
2C66:  BRA    2C64
2C68:  MOVWF  FAD
....................           
....................         //proszenie o zgloszenie 
....................         if (buffer[0] == 'P'){ 
2C6A:  MOVF   16,W
2C6C:  SUBLW  50
2C6E:  BNZ   2C72
....................               caniamlive(); 
2C70:  BRA    25B2
....................         }          
....................  
....................          //wywolanie alarmu z can 
....................          if (buffer[0] == 'a' && buffer[1] =='2'){ 
2C72:  MOVF   16,W
2C74:  SUBLW  61
2C76:  BNZ   2CA4
2C78:  MOVF   17,W
2C7A:  SUBLW  32
2C7C:  BNZ   2CA4
....................                     alarm(); 
....................          } 
....................  
....................          //pytanie o stan centrali 
....................          if (buffer[0] == 's'){ 
*
2CA4:  MOVF   16,W
2CA6:  SUBLW  73
2CA8:  BNZ   2CB6
....................                 delay_ms(200); 
2CAA:  MOVLW  C8
2CAC:  MOVWF  30
2CAE:  CALL   0628
....................                 //wyslanie stanu do czytnika 
....................                 sendalarmstate(); 
2CB2:  CALL   0EAA
....................          } 
....................  
....................          //otrzymano dane karty 
....................          if (buffer[0] == 'c'){                       
2CB6:  MOVF   16,W
2CB8:  SUBLW  63
2CBA:  BNZ   2D1E
....................             //czy karta znana 
....................             if (card_know(buffer[1]) == 1){ 
2CBC:  MOVFF  17,2F
2CC0:  BRA    25EA
2CC2:  DECFSZ 01,W
2CC4:  BRA    2D12
....................                //jesli byl alarm to rozbroic 
....................                 if (state == st_alarm){ 
2CC6:  MOVF   07,W
2CC8:  SUBLW  02
2CCA:  BNZ   2CDC
....................                        printf("alarm off and unarmed\n"); 
2CCC:  MOVLW  F0
2CCE:  MOVWF  FF6
2CD0:  MOVLW  05
2CD2:  MOVWF  FF7
2CD4:  CALL   064E
....................                        state = st_unarmed; 
2CD8:  CLRF   07
....................                 } 
2CDA:  BRA    2D00
....................                 else{ 
....................                   //jesli byl uzbrojony, to rozbroic 
....................                    if (state == st_armed){ 
2CDC:  DECFSZ 07,W
2CDE:  BRA    2CF0
....................                           printf("unarmed\n"); 
2CE0:  MOVLW  08
2CE2:  MOVWF  FF6
2CE4:  MOVLW  06
2CE6:  MOVWF  FF7
2CE8:  CALL   064E
....................                           state = st_unarmed; 
2CEC:  CLRF   07
....................                    } 
2CEE:  BRA    2D00
....................                    //jesli byl rozbrojony to uzbroic 
....................                    else { 
....................                          printf("armed\n"); 
2CF0:  MOVLW  12
2CF2:  MOVWF  FF6
2CF4:  MOVLW  06
2CF6:  MOVWF  FF7
2CF8:  CALL   064E
....................                          state = st_armed; 
2CFC:  MOVLW  01
2CFE:  MOVWF  07
....................                    } 
....................                 } 
....................                 delay_ms(300); 
2D00:  MOVLW  02
2D02:  MOVWF  2F
2D04:  MOVLW  96
2D06:  MOVWF  30
2D08:  CALL   0628
2D0C:  DECFSZ 2F,F
2D0E:  BRA    2D04
....................               } 
2D10:  BRA    2D1E
....................              //karta nieznana 
....................              else{ 
....................                 printf("unknown card\n"); 
2D12:  MOVLW  1A
2D14:  MOVWF  FF6
2D16:  MOVLW  06
2D18:  MOVWF  FF7
2D1A:  CALL   064E
2D1E:  MOVLB  E
....................              } 
....................           }  
....................  
....................         }  
....................       }  
2D20:  MOVLB  0
2D22:  BRA    270E
....................        
....................   
....................               
....................   }  
....................  
.................... } 
2D24:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 7C7E   PUT BROWNOUT BORV18 ZPBORM NOWDT WDT1048576
   Word  3: 8900   CANB MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
